Project Path: blackiya

Source Tree:

```txt
blackiya
‚îú‚îÄ‚îÄ AGENTS.md
‚îú‚îÄ‚îÄ CHANGELOG.md
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ entrypoints
‚îÇ   ‚îú‚îÄ‚îÄ background.ts
‚îÇ   ‚îú‚îÄ‚îÄ interceptor.content.ts
‚îÇ   ‚îú‚îÄ‚îÄ main.content.ts
‚îÇ   ‚îî‚îÄ‚îÄ popup
‚îÇ       ‚îú‚îÄ‚îÄ App.tsx
‚îÇ       ‚îî‚îÄ‚îÄ main.tsx
‚îú‚îÄ‚îÄ platforms
‚îÇ   ‚îú‚îÄ‚îÄ chatgpt.test.ts
‚îÇ   ‚îú‚îÄ‚îÄ chatgpt.ts
‚îÇ   ‚îú‚îÄ‚îÄ constants.ts
‚îÇ   ‚îú‚îÄ‚îÄ factory.ts
‚îÇ   ‚îú‚îÄ‚îÄ gemini.test.ts
‚îÇ   ‚îú‚îÄ‚îÄ gemini.ts
‚îÇ   ‚îú‚îÄ‚îÄ grok.test.ts
‚îÇ   ‚îú‚îÄ‚îÄ grok.ts
‚îÇ   ‚îî‚îÄ‚îÄ types.ts
‚îú‚îÄ‚îÄ reviews
‚îÇ   ‚îî‚îÄ‚îÄ synthesis.md
‚îú‚îÄ‚îÄ test-setup.ts
‚îú‚îÄ‚îÄ utils
‚îÇ   ‚îú‚îÄ‚îÄ download.test.ts
‚îÇ   ‚îú‚îÄ‚îÄ download.ts
‚îÇ   ‚îú‚îÄ‚îÄ logger.ts
‚îÇ   ‚îú‚îÄ‚îÄ logs-storage.ts
‚îÇ   ‚îú‚îÄ‚îÄ lru-cache.test.ts
‚îÇ   ‚îú‚îÄ‚îÄ lru-cache.ts
‚îÇ   ‚îú‚îÄ‚îÄ managers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ interception-manager.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ navigation-manager.ts
‚îÇ   ‚îú‚îÄ‚îÄ platform-runner.test.ts
‚îÇ   ‚îú‚îÄ‚îÄ platform-runner.ts
‚îÇ   ‚îú‚îÄ‚îÄ types.test.ts
‚îÇ   ‚îú‚îÄ‚îÄ types.ts
‚îÇ   ‚îî‚îÄ‚îÄ ui
‚îÇ       ‚îî‚îÄ‚îÄ button-manager.ts
‚îî‚îÄ‚îÄ wxt.config.ts

```

`AGENTS.md`:

```md
# AGENTS.md - AI Agent Documentation

> **Purpose:** This document provides AI coding agents (Claude, GPT, Cursor, etc.) with comprehensive context about the project's architecture, design patterns, and development guidelines.

## üéØ Project Intent

**Blackiya** is a Chrome browser extension designed to capture and save conversation JSON data from popular Large Language Model platforms (ChatGPT, Gemini, Grok, Claude, etc.).

### Core Objectives

1. **Capture** - Intercept and extract conversation data from LLM web interfaces
2. **Save** - Download conversation JSON to local filesystem
3. **Extensibility** - Support multiple LLM platforms via adapter pattern
4. **Performance** - Minimal overhead, fast builds, instant HMR
5. **Simplicity** - No unnecessary UI frameworks; utility-focused

### Non-Goals

- ‚ùå Real-time conversation syncing
- ‚ùå Cloud storage integration (Phase 7+)
- ‚ùå Complex UI/visualization of conversations
- ‚ùå Conversation editing or modification
- ‚ùå Multi-browser support (Chrome/Chromium only for now)

## üèõÔ∏è Architecture Overview

### High-Level Architecture

```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Browser Tab (ChatGPT)                    ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ  Content Script (main.content.ts)                      ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  - Injects "Save" button into page DOM                 ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  - Listens for intercepted data                        ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  - Routes logs to Background                           ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚îÇ chrome.runtime.sendMessage()
                    ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       Background Service Worker (background.ts)             ‚îÇ
‚îÇ  - Intercepts network requests (via interceptor)            ‚îÇ
‚îÇ  - Processes and stores conversation data                   ‚îÇ
‚îÇ  - Unified sink for all extension logs                      ‚îÇ
‚îÇ  - Saves logs to chrome.storage.local                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚îÇ
                    ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              Platform Adapters (platforms/)                 ‚îÇ
‚îÇ  - ChatGPT, Gemini, Grok (Interface oriented)               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚îÇ
                    ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Popup UI (entrypoints/popup/)            ‚îÇ
‚îÇ  - View log counts                                          ‚îÇ
‚îÇ  - Change log verbosity (Debug/Info/Warn/Error)             ‚îÇ
‚îÇ  - Export debug logs as JSON                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Component Breakdown

#### 1. Background Service Worker (`entrypoints/background.ts`)

**Responsibilities:**
- **API Interception** - Monitor network requests to LLM APIs
- **Data Fetching** - Retrieve conversation JSON from endpoints
- **Message Handling** - Respond to content script requests
- **Download Management** - Trigger file downloads via Chrome API

**Key Functions:**
```typescript
- interceptAPIRequests() // Optional: webRequest API
- fetchConversationData(conversationId: string)
- handleMessage(message: Message, sender: MessageSender)
- downloadJSON(data: ConversationData, filename: string)
```

**Communication:**
- Listens: `chrome.runtime.onMessage`
- Sends: `chrome.tabs.sendMessage()`
- Storage: `chrome.storage.local`
- Logging: **Central sink** for all cross-context logs via `LOG_ENTRY` message type.

#### 2. Popup UI (`entrypoints/popup/`)

**Responsibilities:**
- **Status Monitoring** - Display current log entry count
- **Configuration** - Set the active log level (synced across contexts)
- **Log Export** - Export the structured log buffer as a JSON file
- **Maintenance** - Clear log history

**Key Logic:**
- Uses `browser.storage.local` for settings and log retrieval
- Communicates with `logger` to update verbosity levels dynamically

**Responsibilities:**
- **UI Injection** - Add "Save Conversation" button to page
- **DOM Observation** - Detect page changes (SPA navigation)
- **User Interaction** - Handle button clicks
- **Data Extraction** - Get conversation ID from URL/DOM

**Key Functions:**
```typescript
- injectSaveButton() // Add button to specific DOM location
- observePageChanges() // MutationObserver for SPA navigation
- handleSaveClick() // User interaction handler
- getCurrentConversationId() // Extract ID from page
```

**Platform-Specific:**
- `chatgpt.ts` - ChatGPT-specific selectors and logic
- `gemini.ts` - Gemini-specific selectors and logic
- `grok.ts` - Grok-specific selectors and logic

#### 3. Platform Adapters (`platforms/*.ts`)

**Responsibilities:**
- **API Configuration** - Define endpoints and patterns
- **Data Parsing** - Transform platform-specific JSON
- **URL Handling** - Extract conversation IDs
- **UI Specifications** - Define where/how to inject buttons

**Interface Definition:**
```typescript
export interface LLMPlatform {
  name: string;                    // Platform name (e.g., "ChatGPT")
  urlMatchPattern: string;         // URL pattern for content script matching
  apiEndpointPattern: RegExp;      // Regex for API endpoint detection
  extractConversationId: (url: string) => string | null;
  parseInterceptedData: (data: any, url: string) => ConversationData | null;
  buildApiUrl?: (conversationId: string) => string;
  getButtonInjectionTarget: () => HTMLElement | null;
  formatFilename: (data: ConversationData) => string;
}
```

**Example Implementation:**
```typescript
// platforms/chatgpt.ts
export const chatGPTAdapter: LLMPlatform = {
  name: 'ChatGPT',
  urlMatchPattern: 'https://chatgpt.com/*',
  apiEndpointPattern: /backend-api\/conversation\/[a-f0-9-]+$/,
  
  extractConversationId: (url) => {
    // Implementation using URL object and strict validation
    // Returns string | null
  },
  
  parseInterceptedData: (data, url) => {
    // Returns ConversationData | null
  },
  
  formatFilename: (data) => {
    // Returns sanitized filename string
  },
  
  getButtonInjectionTarget: () => {
    // Returns HTMLElement | null
  }
};

// platforms/gemini.ts
export const geminiAdapter: LLMPlatform = {
  name: 'Gemini',
  urlMatchPattern: 'https://gemini.google.com/*',
  apiEndpointPattern: /\/_\/BardChatUi\/data\/batchexecute.*\?.*rpcids=.*(hNvQHb|MaZiqc)/,
  
  extractConversationId: (url) => {
    // Extracts hex ID from URL: gemini.google.com/app/{id}
  },
  
  parseInterceptedData: (data, url) => {
    // 1. Strips magic header: )]}'
    // 2. Parses double-JSON-encoded batchexecute response
    // 3. Normalizes conversation ID (stripping 'c_' prefix)
    // 4. Reconstructs ConversationData from nested message payload
  },
  
  formatFilename: (data) => {
    // Returns sanitized filename string
  },
  
  getButtonInjectionTarget: () => {
    // Returns header navigation for button injection
  }
};

// platforms/grok.ts
export const grokAdapter: LLMPlatform = {
  name: 'Grok',
  urlMatchPattern: 'https://x.com/i/grok*',
  apiEndpointPattern: /\/i\/api\/graphql\/[^/]+\/(GrokConversationItemsByRestId|GrokHistory)/,
  
  extractConversationId: (url) => {
    // Extracts numeric ID from conversation query param
  },
  
  parseInterceptedData: (data, url) => {
    // 1. Handles GrokHistory for title caching
    // 2. Extracts RestID from URL variables to sync IDs
    // 3. Parses GraphQL response for message items and thinking traces
  },
  
  getButtonInjectionTarget: () => {
    // Targets grok-header or role="banner"
  }
};
```

#### 4. Utility Modules (`utils/*.ts`)

**`utils/storage.ts`** - Chrome storage wrapper
```typescript
export async function saveToStorage(key: string, value: any): Promise<void>
export async function getFromStorage<T>(key: string): Promise<T | null>
export async function removeFromStorage(key: string): Promise<void>
export async function clearStorage(): Promise<void>
```

**`utils/capture.ts`** - Core capture logic
```typescript
export async function captureConversation(conversationId: string): Promise<ConversationData>
export function sanitizeFilename(filename: string): string
export function generateTimestamp(): string
```

**`utils/download.ts`** - Download utilities
```typescript
export function downloadAsJSON(data: any, filename: string): void
export function sanitizeFilename(filename: string): string
export function generateTimestamp(): string
```

**`utils/logger.ts`** - Structured logger
```typescript
export const logger: ExtensionLogger
// Methods: debug, info, warn, error, setLevel
```

**`utils/logs-storage.ts`** - Persistent log management
```typescript
export const logsStorage: {
  saveLog(entry: LogEntry): Promise<void>
  getLogs(): Promise<LogEntry[]>
  clearLogs(): Promise<void>
}
```

**`utils/types.ts`** - TypeScript definitions
```typescript
export interface ConversationData {
  title: string;
  create_time: number;
  update_time: number;
  mapping: Record<string, MessageNode>;
  // ... other fields
}

export interface MessageNode {
  id: string;
  message: Message | null;
  parent: string | null;
  children: string[];
}

export interface Message {
  id: string;
  author: Author;
  content: Content;
  create_time: number | null;
  // ... other fields
}
```

## üîß Tech Stack

### Core Framework
- **WXT v0.20.13** - Next-gen browser extension framework
  - File-based routing for entrypoints
  - Vite-powered for fast HMR
  - Auto-manifest generation
  - TypeScript-first

### Package Manager
- **Bun v1.3+** - Fast JavaScript runtime & package manager
  - Native TypeScript support
  - Built-in test runner
- **tslog v4.x** - Powerful, structured logging for TypeScript
  - JSON transport support
  - Cross-context log formatting

### Code Quality
- **Biome v2.3.11** - Fast linter & formatter (Rust-based)
  - Replaces ESLint + Prettier
  - 340+ lint rules
  - <1s linting for typical projects

### Language
- **TypeScript 5.x** - Type-safe JavaScript
  - Strict mode enabled
  - ES2022 target
  - Path aliases configured

### Browser APIs
- **Chrome Extensions API (Manifest V3)**
  - `chrome.runtime` - Message passing
  - `chrome.storage` - Local storage
  - `chrome.downloads` - File downloads
  - `chrome.tabs` - Tab management
  - `chrome.webRequest` - Network interception (optional)

## üìê Design Patterns

### 1. **Adapter Pattern** (Platform Abstraction)

**Purpose:** Support multiple LLM platforms without code duplication

**Implementation:**
```typescript
// Define common interface
interface LLMPlatform { /* ... */ }

// Implement platform-specific adapters
const chatGPTAdapter: LLMPlatform = { /* ... */ };
const geminiAdapter: LLMPlatform = { /* ... */ };

// Use polymorphically
function captureFromPlatform(adapter: LLMPlatform) {
  const id = adapter.extractConversationId(window.location.href);
  const data = adapter.parseInterceptedData(rawData, window.location.href);
  // ... common logic
}
```

**Benefits:**
- Add new platforms by implementing interface
- Shared core logic in utils/
- Easy testing (mock adapters)

### 2. **Message Passing** (Component Communication)

**Purpose:** Content scripts and background workers communicate

**Pattern:**
```typescript
// Content Script ‚Üí Background
chrome.runtime.sendMessage({
  type: 'CAPTURE_CONVERSATION',
  conversationId: '123'
});

// Background ‚Üí Content Script
chrome.tabs.sendMessage(tabId, {
  type: 'CONVERSATION_READY',
  data: conversationData
});
```

**Message Types:**
- `CAPTURE_CONVERSATION` - Request to capture
- `CONVERSATION_READY` - Data ready for download
- `ERROR` - Error occurred
- `UPDATE_UI` - Update button state

### 3. **Factory Pattern** (Platform Selection)

**Purpose:** Dynamically select appropriate platform adapter

```typescript
// platforms/factory.ts
export function getPlatformAdapter(url: string): LLMPlatform | null {
  if (url.includes('chatgpt.com')) return ChatGPTAdapter;
  if (url.includes('gemini.google.com')) return GeminiAdapter;
  if (url.includes('x.com')) return GrokAdapter;
  return null;
}
```

### 4. **Observer Pattern** (DOM Changes)

**Purpose:** React to SPA navigation without page reloads

```typescript
const observer = new MutationObserver((mutations) => {
  if (conversationChanged(mutations)) {
    reinjectButton();
  }
});

observer.observe(document.body, {
  childList: true,
  subtree: true
});
```

## üìÇ Folder Structure & Conventions

### Directory Organization

```text
blackiya/
‚îú‚îÄ‚îÄ entrypoints/          # WXT entrypoints (auto-detected)
‚îÇ   ‚îú‚îÄ‚îÄ background.ts          # Service worker (SINGLETON)
‚îÇ   ‚îú‚îÄ‚îÄ main.content.ts        # Unified content script for all LLMs
‚îÇ   ‚îú‚îÄ‚îÄ interceptor.content.ts # Fetch interceptor (MAIN world)
‚îÇ   ‚îî‚îÄ‚îÄ popup/                 # Extension popup (OPTIONAL)
‚îÇ       ‚îú‚îÄ‚îÄ index.html
‚îÇ       ‚îî‚îÄ‚îÄ App.tsx
‚îú‚îÄ‚îÄ platforms/            # Platform adapters (CORE LOGIC)
‚îÇ   ‚îú‚îÄ‚îÄ chatgpt.ts        # ChatGPT adapter implementation
‚îÇ   ‚îú‚îÄ‚îÄ gemini.ts         # Gemini adapter implementation
‚îÇ   ‚îú‚îÄ‚îÄ grok.ts           # Grok adapter implementation
‚îÇ   ‚îî‚îÄ‚îÄ types.ts          # LLMPlatform interface
‚îú‚îÄ‚îÄ utils/                # Shared utilities (FRAMEWORK-AGNOSTIC)
‚îÇ   ‚îú‚îÄ‚îÄ storage.ts        # Chrome storage wrapper
‚îÇ   ‚îú‚îÄ‚îÄ capture.ts        # Core capture logic
‚îÇ   ‚îú‚îÄ‚îÄ download.ts       # File download helpers
‚îÇ   ‚îî‚îÄ‚îÄ types.ts          # TypeScript interfaces
‚îú‚îÄ‚îÄ public/               # Static assets
‚îÇ   ‚îî‚îÄ‚îÄ icon/             # Extension icons (16, 48, 128)
‚îî‚îÄ‚îÄ [config files]        # wxt.config.ts, biome.json, etc.
```

### Naming Conventions

**Files:**
- `kebab-case.ts` for all files
- `PascalCase` for classes/interfaces
- `camelCase` for functions/variables

**Exports:**
- Named exports for utilities: `export function captureConversation()`
- Default exports for adapters: `export default ChatGPTAdapter`

**Constants:**
- `UPPER_SNAKE_CASE` for constants: `const API_ENDPOINT = '...'`

### File Headers

Add JSDoc comments to all major files:

```typescript
/**
 * ChatGPT Platform Adapter
 * 
 * Handles conversation capture from ChatGPT platform.
 * Implements LLMPlatform interface for standardized interaction.
 * 
 * @module platforms/chatgpt
 */
```

## üîÑ Development Workflow for AI Agents

### When Adding a New Feature

1. **Identify Component** - Determine which layer (background, content, platform, util)
2. **Check Interface** - Verify if existing interfaces need extension
3. **Implement** - Add feature following patterns above
4. **Update Types** - Add TypeScript types in `utils/types.ts`
5. **Test** - Run `bun run dev` and manually test
6. **Lint** - Run `bun run check` before committing

### When Adding a New Platform

**Step-by-step:**

1. Create adapter: `platforms/new-platform.ts`
   ```typescript
   export const NewPlatformAdapter: LLMPlatform = {
     name: 'NewPlatform',
     urlMatchPattern: 'https://newplatform.com/*',
     apiEndpointPattern: /api-pattern/,
     extractConversationId: (url) => { /* ... */ },
     parseInterceptedData: (data, url) => { /* ... */ },
     getButtonInjectionTarget: () => { /* ... */ },
     formatFilename: (data) => { /* ... */ }
   };
   ```

2. Update `entrypoints/main.content.ts` matches:
   ```typescript
   matches: [
     'https://chatgpt.com/*',
     'https://newplatform.com/*'  // ADD THIS
   ]
   ```

3. Update `wxt.config.ts` host permissions:
   ```typescript
   host_permissions: [
     'https://chatgpt.com/*',
     'https://newplatform.com/*'  // ADD THIS
   ]
   ```

4. Test in dev mode: `bun run dev`

### When Debugging

**Common Issues:**

1. **Button not appearing** ‚Üí Check DOM selectors in content script
2. **API not intercepted** ‚Üí Verify URL patterns in background script
3. **Download fails** ‚Üí Check Chrome permissions in manifest
4. **Build errors** ‚Üí Clear `.output/` and rebuild

**Debug Tools:**

- Chrome DevTools (Console, Network, Sources)
- `chrome://extensions/` ‚Üí Inspect views ‚Üí background page
- `console.log()` in content scripts ‚Üí Page console
- `console.log()` in background ‚Üí Service worker console

## üß™ Testing Guidelines

### Automated Testing
The project uses **Bun Test** for unit and integration testing. Platform adapters must have 100% logic coverage using real-world data fixtures.

**Running Tests:**
```bash
bun test                 # Run all tests
bun test platforms/gemini.test.ts # Test Gemini specifically
```

**Test Data:**
- Test fixtures live in `data/gemini/`, `data/chatgpt/`, and `data/grok/`.
- Use real-world intercepted responses, sanitized for PII.
- Ensure fixtures handle edge cases like literal newlines inside JSON strings.

### Manual Testing Checklist
For each platform:

- [ ] Button injects correctly on page load
- [ ] Button appears after SPA navigation
- [ ] Click triggers conversation capture
- [ ] JSON downloads with correct filename
- [ ] Downloaded JSON is valid and complete (check prompts, responses, thinking logs, and titles)
- [ ] Works on long conversations (>100 messages)

## üìù Code Style Guidelines

### TypeScript Best Practices

**Use explicit types:**
```typescript
// ‚úÖ Good
function captureConversation(id: string): Promise<ConversationData> { }

// ‚ùå Avoid
function captureConversation(id: any): any { }
```

**Prefer interfaces over types:**
```typescript
// ‚úÖ Good
interface ConversationData { }

// ‚ùå Avoid (unless union/intersection needed)
type ConversationData = { }
```

**Use async/await over promises:**
```typescript
// ‚úÖ Good
async function fetchData() {
  const response = await fetch(url);
  return await response.json();
}

// ‚ùå Avoid
function fetchData() {
  return fetch(url).then(r => r.json());
}
```

### Biome Configuration

Project uses Biome for linting/formatting:

- **Indent:** 4 spaces
- **Quotes:** Single quotes (`'`)
- **Semicolons:** Always (`;`)
- **Line width:** 120 characters
- **Trailing commas:** all

Run before committing:
```bash
bun run check  # Auto-fix all issues
```

### Comments

**JSDoc for public APIs:**
```typescript
/**
 * Downloads conversation data as JSON file
 * @param data - Conversation data to download
 * @param filename - Name of the file (without extension)
 * @throws {Error} If download fails
 */
export async function downloadJSON(data: ConversationData, filename: string) { }
```

**Inline comments for complex logic:**
```typescript
// Extract conversation ID from URL path segment
// Format: /c/{conversation-id} or /conversation/{conversation-id}
const id = url.split('/').find(segment => segment.match(/^[a-f0-9-]{36}$/));
```

## üö® Important Constraints

### Chrome Extension Limitations

1. **Manifest V3 Required**
   - Service workers instead of background pages
   - Limited storage (5MB for `chrome.storage.local`)
   - No `eval()` or inline scripts

2. **Content Script Isolation**
   - Cannot access page JavaScript directly
   - Must use `window.postMessage()` for page script communication
   - DOM manipulation only

3. **Background Script Persistence**
   - Service workers terminate after inactivity
   - State must be saved to `chrome.storage`
   - Event-driven architecture only

### Platform-Specific Constraints

**ChatGPT:**
- API endpoint: `https://chatgpt.com/backend-api/conversation/{id}`
- Authentication: Session cookies (handled by browser)
- Rate limiting: Unknown (be respectful)

**Gemini:**
- API protocol: `batchexecute` (POST request with `f.req` parameter)
- RPC ID: `hNvQHb` (primary ID for conversation data fetch)
- Response format: Obfuscated JSON array with security prefix `)]}'\n\n`
- Data structure: Double-JSON encoded payload at `payload[0][0][0]`
- ID normalization: Payload IDs prefixed with `c_` are normalized (prefix removed) to match URL IDs.

**Grok:**
- API protocol: GraphQL (accessible via x.com endpoints)
- Mutation/Query: `GrokConversationItemsByRestId` for messages, `GrokHistory` for titles.
- ID Synchronization: Internal `chat_item_id` in response often differs from the URL `conversation` ID.
- Solution: Extract the true `restId` from the GraphQL `variables` URL query parameter during interception.
- Thinking Content: Located in `deepsearch_headers` nested structure. Avoid simple loops; use declarative pipelines for extraction.

## üß† Lessons Learned (For Future Agents)

### 1. Retroactive Async Data
**Problem:** In Gemini, conversation titles (`MaZiqc` RPC) often arrive after the conversation structure (`hNvQHb` RPC).
**Solution:** Use an internal `activeConversations` Map to store references to live `ConversationData` objects. When the title arrives, mutate the object directly. Since the object is passed by reference to the UI/Cache, everyone sees the updated title immediately.

### 2. Complex Nested JSON
**Problem:** Gemini uses double-triple-JSON encoding where strings are escaped inside arrays which are then escaped inside strings.
**Solution:** Use a robust "balanced bracket" extractor instead of simple regex to find JSON chunks. Standard `JSON.parse` will work if you strip the security prefix `)]}'`.

### 3. Literal Newlines in JSON
**Problem:** Some LLM responses contain literal newlines inside quoted strings, which are technically invalid JSON but common in raw intercepted fragments.
**Solution:** When creating test fixtures, ensure literal newlines inside strings are escaped (`\n`) or cleaned. In tests, cleaning `\n` before parsing may be necessary for raw fragments.

### 4. Interceptor World Isolation
**Problem:** Content scripts cannot access the page's `fetch` or `XHR` objects directly.
**Solution:** Inject a script into the `MAIN` world (see `interceptor.content.ts`) to wrap `XMLHttpRequest`. Communicate back to the `ISOLATED` content script world via `window.postMessage`.

### 5. ID Synchronization Mismatches
**Problem:** Some platforms (like Grok) use different IDs in the URL vs. the internal response data, causing cache lookup failures.
**Solution:** Intercept the API request URL/parameters to retrieve the "source of truth" ID (e.g., `restId` on Grok) and force the parsed data to use that ID as its primary key. This ensures the Content Script (which only sees the URL ID) can find the cached data.

### 6. Cognitive Complexity in Parsers
**Problem:** Deeply nested LLM response structures (like Grok's thinking logs) lead to "Arrow Code" and high cognitive complexity.
**Solution:** Use declarative pipelines (`flatMap`, `filter`, `map`) instead of nested `for` loops and `if` checks. This makes the code easier to maintain and satisfies linter rules without suppressions.

### 7. Absolute Import Refactoring
**Problem:** Deeply nested relative imports (`../../utils/...`) make moving files difficult and create brittle paths.
**Solution:** Implement `@/` path alias pointing to the root. Ensure `tsconfig.json` and build tools are aligned. Refactor all logic and test imports to use absolute paths.

### 8. Cross-Context Logging Funnel
**Problem:** `console.log` in Content Scripts is hard to retrieve from the Background script or for user export.
**Solution:** Implement a custom `tslog` transport that detects the current context. Content script logs are sent via `chrome.runtime.sendMessage` to the Background worker, which acts as a central sink and writes to `chrome.storage.local`.

### 9. Build-Time Module Resolution Issues
**Problem:** Certain WXT modules like `wxt/storage` can cause "Missing specifier" errors during production builds in some environments.
**Solution:** Use the standard `browser` polyfill from `wxt/browser` and access `browser.storage.local` directly for critical utilities like the logger. This avoids build-time resolution overhead for virtual modules.

## üéì Learning Resources

For AI agents unfamiliar with concepts:

- **WXT Framework:** [WXT Guide](https://wxt.dev/guide/)
- **Chrome Extensions:** [Chrome Extensions MV3](https://developer.chrome.com/docs/extensions/mv3/)
- **Manifest V3 Migration:** [Migration Guide](https://developer.chrome.com/docs/extensions/migrating/)
- **Content Scripts:** [Content Scripts](https://developer.chrome.com/docs/extensions/mv3/content_scripts/)
- **Message Passing:** [Message Passing](https://developer.chrome.com/docs/extensions/mv3/messaging/)

## üìã Quick Reference

### Key Commands

```bash
bun install          # Install dependencies
bun run dev          # Start development server
bun run build        # Production build
bun run check        # Lint & format (auto-fix)
```

### Important Files

- `wxt.config.ts` - Extension manifest configuration
- `biome.json` - Linting/formatting rules
- `utils/types.ts` - Shared TypeScript types
- `platforms/types.ts` - Platform interface definitions

### Chrome APIs to Use

- `chrome.runtime.sendMessage()` - Send messages
- `chrome.runtime.onMessage.addListener()` - Receive messages
- `chrome.storage.local.get/set()` - Persist data
- `chrome.downloads.download()` - Download files
- `chrome.tabs.query()` - Get active tab
+
+## üì∏ Codebase Snapshots for Reviews
+
+To provide a clean, comprehensive view of the codebase for AI agent reviews, use the following `code2prompt` command. This command specifically targets source and documentation files while excluding build artifacts and binary assets.
+
+```bash
+# Generate a focused snapshot of .ts, .tsx, and .md files
+code2prompt . \
+  -i "**/*.ts,**/*.tsx,**/*.md" \
+  -e "node_modules,.output,.wxt,.git,bun.lock,bun.lockb" \
+  > codebase_snapshot.txt
+```
+
+**Snapshot Characteristics:**
+- **Included:** All TypeScript source logic, React components, and project documentation (.md).
+- **Excluded:** `node_modules`, build outputs (`.output`, `.wxt`), version control metadata, and package lockfiles.
+- **Format:** Single text file (`codebase_snapshot.txt`) optimized for context window efficiency.

---

```

`CHANGELOG.md`:

```md
# [1.1.0](https://github.com/ragaeeb/blackiya/compare/v1.0.0...v1.1.0) (2026-01-20)


### Features

* **grok:** Add Grok support ([#2](https://github.com/ragaeeb/blackiya/issues/2)) ([2c49891](https://github.com/ragaeeb/blackiya/commit/2c49891f032531f006ee87f7bfcbffec3dd103a7))

# 1.0.0 (2026-01-19)


### Features

* **v1:** Initial bootstrap and build ([#1](https://github.com/ragaeeb/blackiya/issues/1)) ([c85582f](https://github.com/ragaeeb/blackiya/commit/c85582f5bdbacca1fdda1c143b77b1bcbbd74313))


### BREAKING CHANGES

* **v1:** First release

```

`README.md`:

```md
<p align="center">
  <img src="public/icon.png" width="128" alt="Blackiya Logo" />
</p>

# Blackiya

[![wakatime](https://wakatime.com/badge/user/a0b906ce-b8e7-4463-8bce-383238df6d4b/project/c697711b-e0aa-47e9-96bd-1ec21e640d07.svg)](https://wakatime.com/badge/user/a0b906ce-b8e7-4463-8bce-383238df6d4b/project/c697711b-e0aa-47e9-96bd-1ec21e640d07)
[![codecov](https://codecov.io/gh/ragaeeb/blackiya/graph/badge.svg?token=M52GQARSGD)](https://codecov.io/gh/ragaeeb/blackiya)
[![Build Status](https://img.shields.io/github/actions/workflow/status/ragaeeb/blackiya/ci.yml?branch=main)](https://github.com/ragaeeb/blackiya/actions)
[![Version](https://img.shields.io/github/v/release/ragaeeb/blackiya)](https://github.com/ragaeeb/blackiya/releases)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Bun](https://img.shields.io/badge/Bun-%23000000.svg?style=flat&logo=bun&logoColor=white)](https://bun.sh)
[![Biome](https://img.shields.io/badge/Biome-%2360a5fa.svg?style=flat&logo=biome&logoColor=white)](https://biomejs.dev)
[![WXT](https://img.shields.io/badge/WXT-%235d2fbf.svg?style=flat&logo=wxt&logoColor=white)](https://wxt.dev)

A high-performance Chrome extension for capturing and saving conversation JSON from popular LLM platforms (ChatGPT, Gemini, Grok).

## üöÄ Quick Start

### Prerequisites

- **Bun** v1.3+ ([Install Bun](https://bun.sh/docs/installation))
- **Chrome** or **Chromium-based browser**
- **Git**

### Bootstrap Instructions

#### Step 1: Install Bun (if not already installed)

**macOS/Linux:**
```bash
curl -fsSL https://bun.sh/install | bash
```

**Windows:**
```powershell
powershell -c "irm bun.sh/install.ps1 | iex"
```

Verify installation:
```bash
bun --version
```

#### Step 2: Clone or Create Project

### Option A: Clone this repository
```bash
git clone <your-repo-url>
cd blackiya
```

### Option B: Create from scratch
```bash
# Create project directory
mkdir blackiya
cd blackiya

# Initialize git
git init

# Create package.json (see configuration files below)
```

#### Step 3: Install Dependencies

```bash
# Install all dependencies
bun install

# This will install:
# - WXT (extension framework)
# - Biome (linter & formatter)
# - TypeScript dependencies
```

#### Step 4: Project Structure Setup

Create the following directory structure:

```bash
# Create directories
mkdir -p entrypoints/content entrypoints/popup public/icon utils platforms

# Create necessary files
touch wxt.config.ts biome.json tsconfig.json
touch entrypoints/background.ts
touch entrypoints/content/chatgpt.ts
touch utils/storage.ts utils/capture.ts utils/types.ts
touch platforms/chatgpt.ts
```

#### Step 5: Configure Project Files

Copy the configuration files from the source code section below:
- `package.json`
- `wxt.config.ts`
- `biome.json`
- `tsconfig.json`
- `.gitignore`

#### Step 6: Add Extension Icons

Place icon files in `public/icon/`:
- `16.png` (16x16px)
- `48.png` (48x48px)
- `128.png` (128x128px)

> **Tip:** Use a tool like [IconKitchen](https://icon.kitchen/) to generate icons from a single source image.

#### Step 7: Development Server

Start the development server with hot module reload:

```bash
bun run dev
```

This will:
1. Build the extension in development mode
2. Watch for file changes
3. Output to `.output/chrome-mv3/` directory
4. Enable Hot Module Replacement for instant updates

#### Step 8: Load Extension in Chrome

1. Open Chrome and navigate to `chrome://extensions/`
2. Enable **Developer mode** (toggle in top-right corner)
3. Click **Load unpacked**
4. Select the `.output/chrome-mv3/` directory from your project
5. The extension should now appear in your extensions list

#### Step 9: Test the Extension

1. Navigate to [ChatGPT](https://chat.openai.com)
2. Start or open a conversation
3. Look for the injected "Save Conversation" button
4. Click the button to download the conversation JSON

## üì¶ Available Scripts

```bash
# Development
bun run dev              # Start dev server with HMR

# Code Quality
bun run check            # Lint and format code (auto-fix)
bun run lint             # Run Biome linter
bun run format           # Format code with Biome

# Building
bun run build            # Build for production
bun run zip              # Create distributable ZIP file

# Testing
bun test                 # Run tests (when added)
```

## üèóÔ∏è Project Structure

```text
blackiya/
‚îú‚îÄ‚îÄ .output/                    # Build output (git-ignored)
‚îÇ   ‚îî‚îÄ‚îÄ chrome-mv3/            # Chrome extension build
‚îú‚îÄ‚îÄ entrypoints/
‚îÇ   ‚îú‚îÄ‚îÄ background.ts          # Service worker for API interception
‚îÇ   ‚îú‚îÄ‚îÄ main.content.ts        # Unified content script for all LLMs
‚îÇ   ‚îú‚îÄ‚îÄ interceptor.content.ts # Fetch interceptor
‚îÇ   ‚îî‚îÄ‚îÄ popup/
‚îÇ       ‚îú‚îÄ‚îÄ index.html        # Extension popup UI (optional)
‚îÇ       ‚îî‚îÄ‚îÄ App.tsx           # Popup logic (optional)
‚îú‚îÄ‚îÄ platforms/
‚îÇ   ‚îú‚îÄ‚îÄ chatgpt.ts            # ChatGPT platform adapter
‚îÇ   ‚îú‚îÄ‚îÄ gemini.ts             # Gemini platform adapter
‚îÇ   ‚îú‚îÄ‚îÄ grok.ts               # Grok platform adapter
‚îÇ   ‚îî‚îÄ‚îÄ types.ts              # Platform interface definitions
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ storage.ts            # Chrome storage utilities
‚îÇ   ‚îú‚îÄ‚îÄ capture.ts            # Core capture logic
‚îÇ   ‚îú‚îÄ‚îÄ download.ts           # File download utilities
‚îÇ   ‚îî‚îÄ‚îÄ types.ts              # TypeScript type definitions
‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îî‚îÄ‚îÄ icon/                 # Extension icons
‚îÇ       ‚îú‚îÄ‚îÄ 16.png
‚îÇ       ‚îú‚îÄ‚îÄ 48.png
‚îÇ       ‚îî‚îÄ‚îÄ 128.png
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ biome.json                # Biome configuration
‚îú‚îÄ‚îÄ bun.lockb                 # Bun lock file
‚îú‚îÄ‚îÄ package.json              # Project dependencies
‚îú‚îÄ‚îÄ tsconfig.json             # TypeScript configuration
‚îú‚îÄ‚îÄ wxt.config.ts             # WXT framework configuration
‚îú‚îÄ‚îÄ AGENTS.md                 # AI agent documentation
‚îî‚îÄ‚îÄ README.md                 # This file
```

## üéØ Features

- ‚úÖ **Full Capture**: Capture complete conversation JSON from ChatGPT, Gemini, and Grok.
- ‚úÖ **Gemini Advanced**: Support for Gemini's `batchexecute` protocol, including **Thinking/Reasoning logs**.
- ‚úÖ **Grok Support**: Full support for Grok's GraphQL API, including conversation history and thinking traces.
- ‚úÖ **Smart Titles**: Automatic conversation title capture (with retroactive updates for async title loads).
- ‚úÖ **One-Click Download**: Instant download as formatted JSON file.
- ‚úÖ **Automatic Naming**: Filenames generated from conversation titles and timestamps.
- ‚úÖ **Robust UI**: Seamless button injection into ChatGPT, Gemini, and Grok interfaces.
- ‚úÖ **Message Tree**: Preserves complete nested message structure.
- ‚úÖ **Extensive Testing**: 100% test coverage for platform adapters (Gemini/ChatGPT/Grok).
- ‚úÖ **Absolute Imports**: Cleaner codebase using `@/` path aliases.
- ‚úÖ **Automated Releases**: CI/CD pipeline with Semantic Versioning and automated GitHub Releases.
- ‚úÖ **Advanced Logging**: Structured, exportable debug logs with privacy-focused persistent storage.


### Roadmap

- ‚úÖ **Phase 1:** ChatGPT support
- ‚úÖ **Phase 2:** Gemini support (including Reasoning & Titles)
- ‚úÖ **Phase 2.5:** Robust Unit Testing Suite
- ‚úÖ **Phase 3:** Grok support
- ‚úÖ **Phase 3.5:** Absolute Import Refactoring & Release Automation
- üî≤ **Phase 4:** Claude support
- üî≤ **Phase 5:** Export formats (Markdown, HTML, PDF)
- üî≤ **Phase 6:** Settings UI for customization
- üî≤ **Phase 7:** Conversation history browser

## üîß Configuration

### Manifest V3 Permissions

The extension requires the following permissions:

- **`storage`** - Save user preferences and temporary data
- **`downloads`** - Download conversation JSON files
- **`webRequest`** - Intercept API requests (optional, for auto-capture)
- **`activeTab`** - Access current tab for UI injection

### Host Permissions

- `https://chatgpt.com/*` - ChatGPT platform
- `https://chat.openai.com/*` - Legacy ChatGPT platform
- `https://gemini.google.com/*` - Gemini platform
- `https://x.com/i/grok*` - Grok platform

## üß™ Development Workflow

### Making Changes

1. Edit source files in `entrypoints/`, `utils/`, or `platforms/`
2. Save the file
3. WXT will automatically rebuild (watch mode)
4. Reload the extension in Chrome if needed (background script changes)
5. Refresh the target webpage (content script changes)

### Adding a New Platform

1. Create platform adapter in `platforms/your-platform.ts`
2. Implement the `LLMPlatform` interface
3. Create content script in `entrypoints/content/your-platform.ts`
4. Register in `wxt.config.ts` host permissions
5. Update background script to handle the new platform

### Code Quality

Before committing:

```bash
# Format and lint all files
bun run check

# Or separately
bun run format  # Format code
bun run lint    # Check for issues
```

### Building for Production

```bash
# Create optimized build
bun run build

# Create ZIP for Chrome Web Store submission
bun run zip
```

The ZIP file will be in `.output/` directory.

## üìù Usage

### Basic Usage

1. Navigate to ChatGPT or Gemini and open a conversation
2. Click the "Save JSON" button (injected by extension)
3. The conversation JSON will download automatically
4. File format: `{conversation-title}_{timestamp}.json`

### Manual Capture

If the auto-inject button doesn't appear:

1. Open the extension popup (click extension icon)
2. Click "Capture Current Conversation"
3. The JSON will download

### Viewing Saved Conversations

The JSON file contains:
- Full conversation metadata (title, timestamps)
- Complete message tree structure
- All message content and metadata
- Model information
- Plugin IDs (if any)

### Exporting Debug Logs

1. Click the extension icon to open the Popup UI.
2. View current log count and adjust the **Log Level** (Debug/Info/Warn/Error).
3. Click "Export Debug Logs" to download a JSON file containing internal extension logs.
4. Useful for bug reporting and troubleshooting.

## üêõ Troubleshooting

### Extension Not Loading

1. Check Chrome console for errors: `chrome://extensions/` > Details > Inspect views
2. Ensure `.output/chrome-mv3/` directory exists
3. Rebuild: `bun run build`

### Button Not Appearing

1. Check if you're on a supported platform (chatgpt.com)
2. Open browser console and check for errors
3. Reload the extension: `chrome://extensions/` > Reload
4. Refresh the webpage

### Build Errors

1. Clear output: `rm -rf .output/`
2. Clear cache: `rm -rf node_modules/ bun.lockb`
3. Reinstall: `bun install`
4. Rebuild: `bun run dev`

### Biome Errors

If Biome complains about formatting:

```bash
# Auto-fix all issues
bun run check

# Or format specific files
bunx biome format --write ./entrypoints/
```

## ü§ù Contributing

### Setup for Contributors

1. Fork the repository
2. Clone your fork: `git clone <your-fork-url>`
3. Create a branch: `git checkout -b feature/your-feature`
4. Make changes and commit
5. Run code quality checks: `bun run check`
6. Push and create Pull Request

### Code Style

- Use **Biome** for formatting (configured in `biome.json`)
- Follow TypeScript best practices
- Use meaningful variable names
- Add JSDoc comments for public APIs
- Keep functions small and focused

### Commit Guidelines

We follow **Semantic Versioning** rules. The extension version is automatically bumped based on your commit messages.

Use **[Conventional Commits](https://www.conventionalcommits.org/)**:

- **`feat:`** -> **Minor** version bump (e.g., `1.1.0` -> `1.2.0`)
  - Example: `feat: add grok platform support`
- **`fix:`** -> **Patch** version bump (e.g., `1.1.0` -> `1.1.1`)
  - Example: `fix: resolve button injection timing issue`
- **`BREAKING CHANGE:`** -> **Major** version bump (e.g., `1.1.0` -> `2.0.0`)
  - Example in footer: `BREAKING CHANGE: api structure has completely changed`
- **`docs:`, `chore:`, `refactor:`, `test:`** -> **No** version bump (unless specified otherwise)
  - Example: `docs: update README with troubleshooting`

> **Note:** Pull Requests must be squashed or use these conventions in the merge commit message to trigger the release workflow properly.

## üìÑ License

MIT License - see LICENSE file for details

## üîó Resources

- [WXT Documentation](https://wxt.dev)
- [Chrome Extension API](https://developer.chrome.com/docs/extensions/)
- [Biome Documentation](https://biomejs.dev)
- [Bun Documentation](https://bun.sh)
- [TypeScript Handbook](https://www.typescriptlang.org/docs/)

## üí¨ Support

For issues and questions:
- Open an issue on GitHub
- Check existing issues for solutions
- Read the AGENTS.md file for architecture details

---

# Inspiration for the Name

Inspiration for the name came from AsmƒÅ æ, who was one day rolling around by herself saying: ‚ÄúBlackiya ABC‚Äù.
```

`entrypoints/background.ts`:

```ts
/**
 * Background Service Worker
 *
 * Handles extension lifecycle events and message passing.
 * Currently minimal as the content script handles most functionality.
 *
 * @module entrypoints/background
 */

import { logger } from '@/utils/logger';
import { logsStorage } from '@/utils/logs-storage';

export default defineBackground(() => {
    logger.info('Background service worker started', {
        id: browser.runtime.id,
    });

    // Listen for installation/update events
    browser.runtime.onInstalled.addListener((details) => {
        if (details.reason === 'install') {
            logger.info('Extension installed');
        } else if (details.reason === 'update') {
            logger.info('Extension updated to version', browser.runtime.getManifest().version);
        }
    });

    // Message handler for future extensibility
    // Currently content script handles everything locally
    browser.runtime.onMessage.addListener((message, sender, sendResponse) => {
        // Handle log entries first to avoid re-logging them
        if (message.type === 'LOG_ENTRY') {
            // Check if payload is valid
            if (message.payload) {
                logsStorage.saveLog(message.payload).catch((err) => {
                    console.error('Failed to save log from content script:', err);
                });
            }
            return; // Don't log LOG_ENTRY messages to avoid loops
        }

        logger.info('Received message:', message.type, 'from', sender.tab?.url);

        // Handle different message types
        switch (message.type) {
            case 'PING':
                // Simple ping to check if background is alive
                sendResponse({ success: true, pong: true });
                break;

            default:
                logger.warn('Unknown message type:', message.type);
                sendResponse({ success: false, error: 'Unknown message type' });
        }

        // Return true to indicate async response (even if we respond sync)
        return true;
    });
});

```

`entrypoints/interceptor.content.ts`:

```ts
import { SUPPORTED_PLATFORM_URLS } from '@/platforms/constants';
import { getPlatformAdapterByApiUrl } from '@/platforms/factory';

function log(level: 'info' | 'warn' | 'error', message: string, ...args: any[]) {
    // Keep console output for immediate debugging in the page console
    if (level === 'error') {
        console.error(message, ...args);
    } else if (level === 'warn') {
        console.warn(message, ...args);
    } else {
        console.log(message, ...args);
    }

    // Send to content script for persistence
    window.postMessage(
        {
            type: 'LLM_LOG_ENTRY',
            payload: {
                level,
                message,
                data: args,
                context: 'interceptor',
            },
        },
        '*',
    );
}

export default defineContentScript({
    matches: [...SUPPORTED_PLATFORM_URLS],
    world: 'MAIN',
    runAt: 'document_start',
    main() {
        // Idempotency: prevent double-injection if the extension is reloaded or content script runs twice
        if ((window as any).__BLACKIYA_INTERCEPTED__) {
            log('warn', '[Blackiya] Interceptor already initialized, skipping reinjection.');
            return;
        }
        (window as any).__BLACKIYA_INTERCEPTED__ = true;

        const originalFetch = window.fetch;

        window.fetch = (async (...args: Parameters<typeof fetch>) => {
            const response = await originalFetch(...args);
            const url = args[0] instanceof Request ? args[0].url : String(args[0]);

            const adapter = getPlatformAdapterByApiUrl(url);
            log('info', `[Blackiya] Intercepted fetch: ${url}, Adapter: ${adapter?.name || 'None'}`);

            if (adapter) {
                const clonedResponse = response.clone();
                clonedResponse
                    .text()
                    .then((text) => {
                        window.postMessage(
                            {
                                type: 'LLM_CAPTURE_DATA_INTERCEPTED',
                                url,
                                data: text,
                                platform: adapter.name,
                            },
                            window.location.origin,
                        );
                    })
                    .catch((err) => {
                        log('error', `[Blackiya] Failed to read intercepted response from ${adapter.name}:`, err);
                    });
            }

            return response;
        }) as any;

        // XHR Interceptor
        const XHR = window.XMLHttpRequest;
        const originalOpen = XHR.prototype.open;
        const originalSend = XHR.prototype.send;

        XHR.prototype.open = function (_method: string, url: string | URL, ...args: any[]) {
            (this as any)._url = String(url);
            return originalOpen.apply(this, [_method, url, ...args] as any);
        };

        XHR.prototype.send = function (body?: any) {
            this.addEventListener('load', function () {
                const url = (this as any)._url;
                const adapter = getPlatformAdapterByApiUrl(url);
                log('info', `[Blackiya] Intercepted XHR: ${url}, Adapter: ${adapter?.name || 'None'}`);

                if (adapter) {
                    try {
                        const responseText = this.responseText;
                        window.postMessage(
                            {
                                type: 'LLM_CAPTURE_DATA_INTERCEPTED',
                                url,
                                data: responseText,
                                platform: adapter.name,
                            },
                            window.location.origin,
                        );
                    } catch (e) {
                        log('error', '[Blackiya] Failed to read XHR response', e);
                    }
                }
            });
            return originalSend.call(this, body);
        };

        log('info', '[Blackiya] Fetch & XHR interceptors initialized');
    },
});

```

`entrypoints/main.content.ts`:

```ts
import { SUPPORTED_PLATFORM_URLS } from '@/platforms/constants';
import { runPlatform } from '@/utils/platform-runner';

/**
 * Unified Content Script for all LLM Platforms
 *
 * This script runs on all supported LLM domains and uses the
 * adapter pattern to determine specific behavior.
 */
export default defineContentScript({
    matches: [...SUPPORTED_PLATFORM_URLS],
    runAt: 'document_idle',
    main() {
        runPlatform();
    },
});

```

`entrypoints/popup/App.tsx`:

```tsx
import { useEffect, useState } from 'react';
import { browser } from 'wxt/browser';
import { downloadAsJSON } from '@/utils/download';
import { type LogLevel, logger } from '@/utils/logger';
import { logsStorage } from '@/utils/logs-storage';

const STORAGE_KEY_LEVEL = 'userSettings.logLevel';

function App() {
    const [logLevel, setLogLevel] = useState<LogLevel>('info');
    const [logCount, setLogCount] = useState<number>(0);

    useEffect(() => {
        // Load settings
        browser.storage.local.get(STORAGE_KEY_LEVEL).then((result) => {
            const level = result[STORAGE_KEY_LEVEL] as LogLevel | undefined;
            if (level) {
                setLogLevel(level);
                logger.setLevel(level);
            }
        });

        // Load log stats
        logsStorage.getLogs().then((logs) => {
            setLogCount(logs.length);
        });
    }, []);

    const handleLevelChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
        const newLevel = e.target.value as LogLevel;
        setLogLevel(newLevel);
        browser.storage.local.set({ [STORAGE_KEY_LEVEL]: newLevel });
        logger.setLevel(newLevel);
        logger.info(`Log level changed to ${newLevel}`);
    };

    const handleExport = async () => {
        try {
            const logs = await logsStorage.getLogs();
            if (logs.length === 0) {
                alert('No logs to export.');
                return;
            }

            const timestamp = new Date().toISOString().replace(/[:]/g, '-');
            const filename = `blackiya-logs-${timestamp}`;
            downloadAsJSON(logs, filename);

            logger.info('Logs exported by user');
        } catch (error) {
            console.error('Failed to export logs', error);
            logger.error('Failed to export logs', error);
        }
    };

    const handleClear = async () => {
        if (confirm('Are you sure you want to clear all logs?')) {
            await logsStorage.clearLogs();
            setLogCount(0);
            logger.info('Logs cleared by user');
        }
    };

    return (
        <div>
            <div className="title">
                <img src="/icon.svg" width="24" height="24" alt="Icon" />
                Blackiya Settings
            </div>

            <div className="section">
                <label htmlFor="logLevel">Log Level</label>
                <select id="logLevel" value={logLevel} onChange={handleLevelChange}>
                    <option value="debug">Debug</option>
                    <option value="info">Info</option>
                    <option value="warn">Warn</option>
                    <option value="error">Error</option>
                </select>
                <div style={{ fontSize: '12px', color: '#666' }}>Current Logs: {logCount} entries</div>
            </div>

            <button type="button" className="primary" onClick={handleExport}>
                Export Debug Logs
            </button>

            <button type="button" className="secondary" onClick={handleClear}>
                Clear Logs
            </button>
        </div>
    );
}

export default App;

```

`entrypoints/popup/main.tsx`:

```tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './style.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
);

```

`platforms/chatgpt.test.ts`:

```ts
/**
 * Tests for ChatGPT Platform Adapter
 *
 * TDD tests for conversation ID extraction, API URL building, and filename formatting
 */

import { describe, expect, it } from 'bun:test';
import { chatGPTAdapter } from '@/platforms/chatgpt';

describe('ChatGPT Platform Adapter', () => {
    describe('extractConversationId', () => {
        it('should extract conversation ID from standard chat URL', () => {
            const url = 'https://chatgpt.com/c/696bc3d5-fa84-8328-b209-4d65cb229e59';
            const id = chatGPTAdapter.extractConversationId(url);
            expect(id).toBe('696bc3d5-fa84-8328-b209-4d65cb229e59');
        });

        it('should extract conversation ID from GPT/gizmo URL format', () => {
            const url = 'https://chatgpt.com/g/g-abc123/c/696bc3d5-fa84-8328-b209-4d65cb229e59';
            const id = chatGPTAdapter.extractConversationId(url);
            expect(id).toBe('696bc3d5-fa84-8328-b209-4d65cb229e59');
        });

        it('should extract conversation ID from URL with query parameters', () => {
            const url = 'https://chatgpt.com/c/696bc3d5-fa84-8328-b209-4d65cb229e59?model=gpt-4';
            const id = chatGPTAdapter.extractConversationId(url);
            expect(id).toBe('696bc3d5-fa84-8328-b209-4d65cb229e59');
        });

        it('should return null for homepage URL', () => {
            const url = 'https://chatgpt.com/';
            const id = chatGPTAdapter.extractConversationId(url);
            expect(id).toBeNull();
        });

        it('should return null for non-ChatGPT URL', () => {
            const url = 'https://google.com/c/123';
            const id = chatGPTAdapter.extractConversationId(url);
            expect(id).toBeNull();
        });

        it('should return null for invalid conversation ID format', () => {
            const url = 'https://chatgpt.com/c/invalid-id';
            const id = chatGPTAdapter.extractConversationId(url);
            expect(id).toBeNull();
        });

        it('should handle chat.openai.com legacy domain', () => {
            const url = 'https://chat.openai.com/c/696bc3d5-fa84-8328-b209-4d65cb229e59';
            const id = chatGPTAdapter.extractConversationId(url);
            expect(id).toBe('696bc3d5-fa84-8328-b209-4d65cb229e59');
        });
    });

    describe('parseInterceptedData', () => {
        it('should parse valid ChatGPT JSON data', () => {
            const mockData = {
                title: 'Test Conversation',
                conversation_id: 'uuid-123',
                mapping: { 'node-1': {} },
            };
            const result = chatGPTAdapter.parseInterceptedData(JSON.stringify(mockData), 'url');
            expect(result).not.toBeNull();
            expect(result?.title).toBe('Test Conversation');
        });

        it('should return null for invalid data', () => {
            const result = chatGPTAdapter.parseInterceptedData(JSON.stringify({ foo: 'bar' }), 'url');
            expect(result).toBeNull();
        });
    });

    describe('formatFilename', () => {
        it('should format filename with title and timestamp', () => {
            const data = {
                title: 'Test Conversation',
                create_time: 1768670166.492617,
                update_time: 1768671022.523312,
                mapping: {},
                conversation_id: '696bc3d5-fa84-8328-b209-4d65cb229e59',
                current_node: 'node-1',
                moderation_results: [],
                plugin_ids: null,
                gizmo_id: null,
                gizmo_type: null,
                is_archived: false,
                default_model_slug: 'gpt-4',
                safe_urls: [],
                blocked_urls: [],
            };

            const filename = chatGPTAdapter.formatFilename(data);

            // Should contain sanitized title
            expect(filename).toContain('Test_Conversation');
            // Should contain timestamp
            expect(filename).toMatch(/\d{4}-\d{2}-\d{2}/);
        });

        it('should sanitize special characters in title', () => {
            const data = {
                title: 'Test: Special/Characters\\Here?',
                create_time: 1768670166.492617,
                update_time: 1768671022.523312,
                mapping: {},
                conversation_id: '696bc3d5-fa84-8328-b209-4d65cb229e59',
                current_node: 'node-1',
                moderation_results: [],
                plugin_ids: null,
                gizmo_id: null,
                gizmo_type: null,
                is_archived: false,
                default_model_slug: 'gpt-4',
                safe_urls: [],
                blocked_urls: [],
            };

            const filename = chatGPTAdapter.formatFilename(data);

            // Should not contain invalid filename characters
            expect(filename).not.toMatch(/[:/\\?<>"|*]/);
        });

        it('should handle empty title', () => {
            const data = {
                title: '',
                create_time: 1768670166.492617,
                update_time: 1768671022.523312,
                mapping: {},
                conversation_id: '696bc3d5-fa84-8328-b209-4d65cb229e59',
                current_node: 'node-1',
                moderation_results: [],
                plugin_ids: null,
                gizmo_id: null,
                gizmo_type: null,
                is_archived: false,
                default_model_slug: 'gpt-4',
                safe_urls: [],
                blocked_urls: [],
            };

            const filename = chatGPTAdapter.formatFilename(data);

            // Should use conversation ID prefix for untitled conversations
            expect(filename).toContain('conversation');
        });

        it('should truncate very long titles', () => {
            const longTitle = 'A'.repeat(200);
            const data = {
                title: longTitle,
                create_time: 1768670166.492617,
                update_time: 1768671022.523312,
                mapping: {},
                conversation_id: '696bc3d5-fa84-8328-b209-4d65cb229e59',
                current_node: 'node-1',
                moderation_results: [],
                plugin_ids: null,
                gizmo_id: null,
                gizmo_type: null,
                is_archived: false,
                default_model_slug: 'gpt-4',
                safe_urls: [],
                blocked_urls: [],
            };

            const filename = chatGPTAdapter.formatFilename(data);

            // Filename should be reasonable length (under 100 chars for title part)
            expect(filename.length).toBeLessThan(150);
        });
    });

    describe('apiEndpointPattern', () => {
        it('should match ChatGPT conversation API endpoint', () => {
            const endpoint = 'https://chatgpt.com/backend-api/conversation/696bc3d5-fa84-8328-b209-4d65cb229e59';
            expect(chatGPTAdapter.apiEndpointPattern.test(endpoint)).toBe(true);
        });

        it('should not match other API endpoints', () => {
            const endpoint = 'https://chatgpt.com/backend-api/models';
            expect(chatGPTAdapter.apiEndpointPattern.test(endpoint)).toBe(false);
        });
    });
});

```

`platforms/chatgpt.ts`:

```ts
/**
 * ChatGPT Platform Adapter
 *
 * Implements the LLMPlatform interface for ChatGPT.
 * Handles conversation ID extraction, API URL building, and filename formatting.
 *
 * @module platforms/chatgpt
 */

import type { LLMPlatform } from '@/platforms/types';
import { generateTimestamp, sanitizeFilename } from '@/utils/download';
import { logger } from '@/utils/logger';
import type { ConversationData } from '@/utils/types';

/**
 * Maximum length for the title portion of a filename
 */
const MAX_TITLE_LENGTH = 80;

/**
 * Regex pattern to match a valid ChatGPT conversation UUID
 * Format: 8-4-4-4-12 hex characters
 * Anchored and case-insensitive
 */
const CONVERSATION_ID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/i;

/**
 * ChatGPT Platform Adapter
 *
 * Supports both chatgpt.com and legacy chat.openai.com domains.
 * Handles standard /c/{id} format and gizmo /g/{gizmo}/c/{id} format.
 */
export const chatGPTAdapter: LLMPlatform = {
    name: 'ChatGPT',

    urlMatchPattern: 'https://chatgpt.com/*',

    apiEndpointPattern: /backend-api\/conversation\/[a-f0-9-]+$/,

    /**
     * Check if a URL belongs to ChatGPT
     */
    isPlatformUrl(url: string): boolean {
        return url.includes('chatgpt.com') || url.includes('chat.openai.com');
    },

    /**
     * Extract conversation ID from ChatGPT URL
     *
     * Supports:
     * - https://chatgpt.com/c/{uuid}
     * - https://chatgpt.com/g/{gizmo-id}/c/{uuid}
     * - https://chat.openai.com/c/{uuid} (legacy)
     * - URLs with query parameters
     *
     * @param url - The current page URL
     * @returns The conversation UUID or null if not found/invalid
     */
    extractConversationId(url: string): string | null {
        try {
            const urlObj = new URL(url);

            // Validate strict hostname
            if (urlObj.hostname !== 'chatgpt.com' && urlObj.hostname !== 'chat.openai.com') {
                return null;
            }

            // Look for /c/{uuid} pattern in the pathname
            const pathMatch = urlObj.pathname.match(/\/c\/([a-f0-9-]+)/i);
            if (!pathMatch) {
                return null;
            }

            const potentialId = pathMatch[1];

            // Validate it's a proper UUID format
            if (!CONVERSATION_ID_PATTERN.test(potentialId)) {
                return null;
            }

            return potentialId;
        } catch {
            // Invalid URL format
            return null;
        }
    },

    /**
     * Parse intercepted ChatGPT API response
     *
     * @param data - Raw text or parsed object
     * @param _url - The API endpoint URL
     * @returns Validated ConversationData or null
     */
    parseInterceptedData(data: string | any, _url: string): ConversationData | null {
        try {
            const parsed = typeof data === 'string' ? JSON.parse(data) : data;

            // Basic validation of ChatGPT structure
            if (parsed && typeof parsed.title === 'string' && parsed.mapping) {
                return parsed as ConversationData;
            }
        } catch (e) {
            logger.error('Failed to parse ChatGPT data:', e);
        }
        return null;
    },

    /**
     * Format a filename for the downloaded JSON
     *
     * Format: {sanitized_title}_{YYYY-MM-DD_HH-MM-SS}
     *
     * @param data - The conversation data
     * @returns A sanitized filename (without .json extension)
     */
    formatFilename(data: ConversationData): string {
        let title = data.title || '';

        // If no title, use a default with part of conversation ID
        if (!title.trim()) {
            title = `conversation_${data.conversation_id.slice(0, 8)}`;
        }

        // Sanitize and truncate title
        let sanitizedTitle = sanitizeFilename(title);
        if (sanitizedTitle.length > MAX_TITLE_LENGTH) {
            sanitizedTitle = sanitizedTitle.slice(0, MAX_TITLE_LENGTH);
        }

        // Generate timestamp from update_time or create_time
        const timestamp = generateTimestamp(data.update_time || data.create_time);

        return `${sanitizedTitle}_${timestamp}`;
    },

    /**
     * Find injection target in ChatGPT UI
     */
    getButtonInjectionTarget(): HTMLElement | null {
        const selectors = [
            '[data-testid="model-switcher-dropdown-button"]',
            'header nav',
            '.flex.items-center.justify-between',
            'header .flex',
        ];

        for (const selector of selectors) {
            const target = document.querySelector(selector);
            if (target) {
                return (target.parentElement || target) as HTMLElement;
            }
        }
        return null;
    },
};

```

`platforms/constants.ts`:

```ts
/**
 * Platform Constants
 *
 * Shared constants for all supported LLM platforms
 * Used across configuration, content scripts, and interceptors
 *
 * @module platforms/constants
 */

/**
 * Supported LLM Platform URLs
 * These patterns are used in:
 * - wxt.config.ts (host_permissions)
 * - entrypoints/main.content.ts (content script matches)
 * - entrypoints/interceptor.content.ts (interceptor matches)
 */
export const SUPPORTED_PLATFORM_URLS = [
    'https://chatgpt.com/*',
    'https://chat.openai.com/*',
    'https://gemini.google.com/*',
    'https://x.com/i/grok*',
] as const;

/**
 * Type-safe platform URL type
 */
export type PlatformUrl = (typeof SUPPORTED_PLATFORM_URLS)[number];

```

`platforms/factory.ts`:

```ts
/**
 * Platform Adapter Factory
 *
 * Manages the registration and selection of platform-specific adapters.
 */

import { chatGPTAdapter } from '@/platforms/chatgpt';
import { geminiAdapter } from '@/platforms/gemini';
import { grokAdapter } from '@/platforms/grok';
import type { LLMPlatform } from '@/platforms/types';

/**
 * Get all supported platforms
 * Lazy-loaded to avoid circular dependencies
 */
function getPlatforms(): LLMPlatform[] {
    return [chatGPTAdapter, geminiAdapter, grokAdapter];
}

/**
 * Get the appropriate platform adapter for a given URL
 *
 * @param url - The URL to check (either page URL or API URL)
 * @returns The matching platform adapter or null if not found
 */
export function getPlatformAdapter(url: string): LLMPlatform | null {
    return getPlatforms().find((p) => p.isPlatformUrl(url)) || null;
}

/**
 * Get the platform adapter that matches an API endpoint URL
 *
 * @param url - The intercepted API endpoint URL
 * @returns The matching platform adapter or null if not found
 */
export function getPlatformAdapterByApiUrl(url: string): LLMPlatform | null {
    return getPlatforms().find((p) => p.apiEndpointPattern.test(url)) || null;
}

```

`platforms/gemini.test.ts`:

```ts
import { beforeAll, describe, expect, it, mock } from 'bun:test';
import { join } from 'node:path';

// Mock wxt/browser explicitly to avoid logging errors
const browserMock = {
    storage: {
        local: {
            get: async () => ({}),
            set: async () => {},
        },
    },
    runtime: {
        getURL: () => 'chrome-extension://mock/',
    },
};
mock.module('wxt/browser', () => ({
    browser: browserMock,
}));

import { geminiAdapter } from '@/platforms/gemini';
import type { Message } from '@/utils/types';

describe('Gemini Platform Adapter', () => {
    let conversationResponseRaw: string;
    let titlesResponseRaw: string;

    beforeAll(async () => {
        // Load test fixtures from the data/gemini folder
        // Use join(import.meta.dir, '..', 'data', ...) to go up from platforms/ to root
        conversationResponseRaw = await Bun.file(
            join(import.meta.dir, '..', 'data', 'gemini', 'sample_gemini_conversation.txt'),
        ).text();
        titlesResponseRaw = await Bun.file(
            join(import.meta.dir, '..', 'data', 'gemini', 'sample_gemini_titles.txt'),
        ).text();
    });

    describe('URL Handling', () => {
        it('should identify Gemini URLs', () => {
            expect(geminiAdapter.isPlatformUrl('https://gemini.google.com/app/12345')).toBe(true);
            expect(geminiAdapter.isPlatformUrl('https://gemini.google.com/')).toBe(true);
            expect(geminiAdapter.isPlatformUrl('https://google.com')).toBe(false);
        });

        it('should extract conversation IDs', () => {
            expect(geminiAdapter.extractConversationId('https://gemini.google.com/app/abcdef123')).toBe('abcdef123');
            expect(geminiAdapter.extractConversationId('https://gemini.google.com/share/shared_id_123')).toBe(
                'shared_id_123',
            );
            expect(geminiAdapter.extractConversationId('https://gemini.google.com')).toBeNull();
        });
    });

    describe('API Pattern Matching', () => {
        it('should match valid batchexecute URLs', () => {
            const pattern = geminiAdapter.apiEndpointPattern;
            expect(pattern.test('https://gemini.google.com/_/BardChatUi/data/batchexecute?rpcids=hNvQHb')).toBe(true);
            expect(pattern.test('https://gemini.google.com/_/BardChatUi/data/batchexecute?rpcids=MaZiqc')).toBe(true);
            expect(
                pattern.test('https://gemini.google.com/_/BardChatUi/data/batchexecute?v=1&rpcids=hNvQHb&test=1'),
            ).toBe(true);
        });

        it('should NOT match irrelevant batchexecute URLs', () => {
            const pattern = geminiAdapter.apiEndpointPattern;
            expect(pattern.test('https://gemini.google.com/_/BardChatUi/data/batchexecute?rpcids=otAQ7b')).toBe(false);
            expect(pattern.test('https://gemini.google.com/_/BardChatUi/data/batchexecute')).toBe(false); // No rpcids
        });
    });

    describe('Conversation Data Parsing', () => {
        it('should parse a full conversation correctly (User + Assistant + Reasoning)', () => {
            const url = 'https://gemini.google.com/app/9cf87bbddf79d497';
            const result = geminiAdapter.parseInterceptedData(conversationResponseRaw, url);

            expect(result).not.toBeNull();
            if (!result) {
                return;
            }

            expect(result.conversation_id).toBe('9cf87bbddf79d497');
            expect(result.default_model_slug).toBe('gemini-3-pro');

            const mapping = result.mapping;
            expect(mapping).toBeDefined();

            // Filter out null messages to avoid TS errors
            const messages = Object.values(mapping)
                .map((n) => n.message)
                .filter((m): m is Message => m !== null);

            expect(messages.length).toBe(2);

            // 1. Strict User Message Validation
            const userMsg = messages.find((m) => m.author.role === 'user')!;
            expect(userMsg).toBeDefined();
            const userText = userMsg.content.parts?.[0] || '';

            expect(userText.startsWith('ROLE: Expert academic translator')).toBe(true);
            expect(userText.endsWith('ÿØÿ®ÿ± ÿßŸÑÿµŸÑŸàÿßÿ™ ŸäŸèÿ§ÿ™Ÿâ ÿ®Ÿáÿß ŸÖÿß Ÿäÿ≥ÿ™ÿ∑Ÿäÿπ ÿßŸÑÿ•ŸÜÿ≥ÿßŸÜ ŸàŸÑŸäÿ≥ ÿ•ŸÑÿß.')).toBe(true);

            // 2. Strict Assistant Message Validation
            const assistantMsg = messages.find((m) => m.author.role === 'assistant')!;
            expect(assistantMsg).toBeDefined();
            const assistantText = assistantMsg.content.parts?.[0] || '';

            expect(assistantText.startsWith('P258071 - The Shaykh: Yes.')).toBe(true);
            expect(assistantText.endsWith('rforms of them what man is able, and nothing else.')).toBe(true);

            // 3. Strict Reasoning/Thoughts Validation
            const thoughts = assistantMsg.content.thoughts;
            expect(thoughts).toBeDefined();
            expect(thoughts!.length).toBe(7);

            const firstThought = thoughts![0];
            expect(firstThought.summary).toBe('Clarifying Key Parameters');
            expect(firstThought.content.startsWith("I've established key parameters for the task. This")).toBe(true);
            expect(firstThought.content.endsWith("ch involves a question on Ibn ·∏§ajar's assessments.")).toBe(true);
        });
    });

    describe('Title Parsing & Race Conditions', () => {
        it('should extract titles and update cache', () => {
            const url = 'https://gemini.google.com/_/BardChatUi/data/batchexecute?rpcids=MaZiqc';
            const result = geminiAdapter.parseInterceptedData(titlesResponseRaw, url);
            expect(result).toBeNull();
        });

        it('should retroactively update conversation title when titles arrive AFTER data', () => {
            const uniqueId = 'test_race_condition';
            // Use a unique ID to avoid interference with other tests
            const modifiedConvData = conversationResponseRaw.replace('9cf87bbddf79d497', uniqueId);

            const convResult = geminiAdapter.parseInterceptedData(
                modifiedConvData,
                `https://gemini.google.com/app/${uniqueId}`,
            );

            expect(convResult).not.toBeNull();
            if (!convResult) {
                return;
            }
            expect(convResult.title).toBe('Gemini Conversation');

            const expectedTitle = 'Test Retroactive Title';
            const modifiedTitles = titlesResponseRaw
                .replace('c_9cf87bbddf79d497', `c_${uniqueId}`)
                .replace('Hadith Authenticity and Narrator Discrepancies', expectedTitle);

            geminiAdapter.parseInterceptedData(
                modifiedTitles,
                'https://gemini.google.com/_/BardChatUi/data/batchexecute?rpcids=MaZiqc',
            );

            expect(convResult.title).toBe(expectedTitle);
        });

        it('should apply cached title if titles arrive BEFORE data', () => {
            const uniqueId = 'test_cached_title';
            const expectedTitle = 'Test Cached Title';

            const modifiedTitles = titlesResponseRaw
                .replace('c_69b38773dc8a64c7', `c_${uniqueId}`)
                .replace('Scholars Discuss Fiqh and Hadith', expectedTitle);

            geminiAdapter.parseInterceptedData(
                modifiedTitles,
                'https://gemini.google.com/_/BardChatUi/data/batchexecute?rpcids=MaZiqc',
            );

            const modifiedConvData = conversationResponseRaw.replace('9cf87bbddf79d497', uniqueId);
            const convResult = geminiAdapter.parseInterceptedData(
                modifiedConvData,
                `https://gemini.google.com/app/${uniqueId}`,
            );

            expect(convResult).not.toBeNull();
            expect(convResult?.title).toBe(expectedTitle);
        });
    });
});

```

`platforms/gemini.ts`:

```ts
/**
 * Gemini Platform Adapter - With Title Support (Enhanced Logging)
 *
 * Enhancements:
 * 1. Intercepts MaZiqc RPC calls to capture conversation titles
 * 2. Caches title mappings (conversationId -> title)
 * 3. Uses cached titles when building ConversationData
 * 4. Enhanced logging to debug title extraction
 */

import type { LLMPlatform } from '@/platforms/types';
import { generateTimestamp, sanitizeFilename } from '@/utils/download';
import { logger } from '@/utils/logger';
import type { ConversationData, MessageNode } from '@/utils/types';

const MAX_TITLE_LENGTH = 80;

import { LRUCache } from '@/utils/lru-cache';

/**
 * We keep a small cache of message-titles to apply them
 * if they arrive *before* the message data.
 */
const conversationTitles = new LRUCache<string, string>(50);

/**
 * We also keep a reference to active conversations so we can update
 * their titles retroactively if the title arrives *after* the data.
 */
const activeConversations = new LRUCache<string, ConversationData>(50);

/**
 * Parse the MaZiqc response to extract conversation titles
 */
// biome-ignore lint/complexity/noExcessiveCognitiveComplexity: Complex parsing logic required for platform
function parseTitlesResponse(data: string, url: string): Map<string, string> | null {
    try {
        logger.info('[Blackiya/Gemini/Titles] Attempting to parse titles from:', url);

        // 1. Strip security prefix
        const MAGIC_HEADER_REGEX = /^\s*\)\s*\]\s*\}\s*'/;
        const cleanedData = data.replace(MAGIC_HEADER_REGEX, '').trim();

        // 2. Find JSON array
        const startBracket = cleanedData.indexOf('[');
        if (startBracket === -1) {
            logger.info('[Blackiya/Gemini/Titles] No JSON array found');
            return null;
        }

        // 3. Extract balanced JSON
        let balance = 0;
        let endBracket = -1;
        let insideString = false;
        let isEscaped = false;

        for (let i = startBracket; i < cleanedData.length; i++) {
            const char = cleanedData[i];

            if (isEscaped) {
                isEscaped = false;
                continue;
            }

            if (char === '\\') {
                isEscaped = true;
                continue;
            }

            if (char === '"') {
                insideString = !insideString;
                continue;
            }

            if (!insideString) {
                if (char === '[') {
                    balance++;
                } else if (char === ']') {
                    balance--;
                    if (balance === 0) {
                        endBracket = i;
                        break;
                    }
                }
            }
        }

        if (endBracket === -1) {
            logger.info('[Blackiya/Gemini/Titles] Could not find balanced JSON array');
            return null;
        }

        const jsonStr = cleanedData.substring(startBracket, endBracket + 1);
        const wrapper = JSON.parse(jsonStr);

        if (!Array.isArray(wrapper) || wrapper.length === 0) {
            logger.info('[Blackiya/Gemini/Titles] Wrapper is not an array or is empty');
            return null;
        }

        // 4. Find the MaZiqc result
        let rpcResult = null;
        for (const item of wrapper) {
            if (Array.isArray(item) && item.length >= 3 && item[0] === 'wrb.fr' && item[1] === 'MaZiqc') {
                rpcResult = item;
                logger.debug('[Blackiya/Gemini/Titles] Found MaZiqc result');
                break;
            }
        }

        if (!rpcResult) {
            logger.debug('[Blackiya/Gemini/Titles] No MaZiqc RPC result found in wrapper');
            return null;
        }

        // 5. Parse the payload
        const payloadStr = rpcResult[2];
        if (typeof payloadStr !== 'string') {
            return null;
        }

        const payload = JSON.parse(payloadStr);

        // 6. Extract conversation list
        // Structure: [null, "token", [[conversationData], ...]]
        if (!Array.isArray(payload) || payload.length < 3) {
            return null;
        }

        const conversationList = payload[2];
        if (!Array.isArray(conversationList)) {
            return null;
        }

        logger.info('[Blackiya/Gemini/Titles] Found conversation list with', conversationList.length, 'entries');

        const titles = new Map<string, string>();

        // 7. Each conversation entry: ["c_id", "title", null, null, null, [timestamp], ...]
        for (const conv of conversationList) {
            if (Array.isArray(conv) && conv.length >= 2) {
                let convId = conv[0];
                const title = conv[1];

                // Normalize ID (remove c_ prefix)
                if (typeof convId === 'string' && convId.startsWith('c_')) {
                    convId = convId.slice(2);
                }

                if (typeof convId === 'string' && typeof title === 'string') {
                    titles.set(convId, title);

                    // Retroactively update any active conversation object
                    if (activeConversations.has(convId)) {
                        const activeObj = activeConversations.get(convId);
                        if (activeObj && activeObj.title !== title) {
                            activeObj.title = title;
                            logger.info(
                                `[Blackiya/Gemini/Titles] Retroactively updated title for active conversation: ${convId} -> "${title}"`,
                            );
                        }
                    }
                }
            }
        }

        return titles;
    } catch (e) {
        logger.error('[Blackiya/Gemini/Titles] Failed to parse titles:', e);
        return null;
    }
}

/**
 * Check if a URL is a MaZiqc (conversation list) endpoint
 */
function isTitlesEndpoint(url: string): boolean {
    const isTitles = url.includes('rpcids=MaZiqc');
    if (isTitles) {
        logger.info('[Blackiya/Gemini/Titles] Detected titles endpoint');
    }
    return isTitles;
}

export const geminiAdapter: LLMPlatform = {
    name: 'Gemini',
    urlMatchPattern: 'https://gemini.google.com/*',

    // Match ANY batchexecute endpoint (both conversation data and titles)
    // Match batchexecute endpoints containing specific RPC IDs:
    // hNvQHb (Conversation Data) OR MaZiqc (Conversation Titles)
    apiEndpointPattern: /\/_\/BardChatUi\/data\/batchexecute.*\?.*rpcids=.*(hNvQHb|MaZiqc)/,

    isPlatformUrl(url: string): boolean {
        return url.includes('gemini.google.com');
    },

    extractConversationId(url: string): string | null {
        if (!this.isPlatformUrl(url)) {
            return null;
        }

        const appMatch = url.match(/\/app\/([a-zA-Z0-9_-]+)/i);
        if (appMatch) {
            return appMatch[1];
        }

        const shareMatch = url.match(/\/share\/([a-zA-Z0-9_-]+)/i);
        if (shareMatch) {
            return shareMatch[1];
        }

        return null;
    },

    // biome-ignore lint/complexity/noExcessiveCognitiveComplexity: Complex parsing logic required for platform
    parseInterceptedData(data: string, url: string): ConversationData | null {
        // Check if this is a titles endpoint
        if (isTitlesEndpoint(url)) {
            const titles = parseTitlesResponse(data, url);
            if (titles) {
                // Merge into global cache
                for (const [id, title] of titles) {
                    conversationTitles.set(id, title);
                }
                logger.info(`[Blackiya/Gemini] Title cache now contains ${conversationTitles.size} entries`);

                // Log current cache contents for debugging
                logger.info(
                    '[Blackiya/Gemini] Current cached conversation IDs:',
                    Array.from(conversationTitles.keys()).slice(0, 5),
                );
            } else {
                logger.info('[Blackiya/Gemini/Titles] Failed to extract titles from this response');
            }
            // Don't return ConversationData for title endpoints
            return null;
        }

        // Otherwise, parse as conversation data
        try {
            logger.info('[Blackiya/Gemini] Attempting to parse response from:', url);

            // 1. Strip security prefix
            const MAGIC_HEADER_REGEX = /^\s*\)\s*\]\s*\}\s*'/;
            const cleanedData = data.replace(MAGIC_HEADER_REGEX, '').trim();

            // 2. Find JSON array
            const startBracket = cleanedData.indexOf('[');
            if (startBracket === -1) {
                logger.info('[Blackiya/Gemini] No JSON array found');
                return null;
            }

            // 3. Extract balanced JSON
            let balance = 0;
            let endBracket = -1;
            let insideString = false;
            let isEscaped = false;

            for (let i = startBracket; i < cleanedData.length; i++) {
                const char = cleanedData[i];

                if (isEscaped) {
                    isEscaped = false;
                    continue;
                }

                if (char === '\\') {
                    isEscaped = true;
                    continue;
                }

                if (char === '"') {
                    insideString = !insideString;
                    continue;
                }

                if (!insideString) {
                    if (char === '[') {
                        balance++;
                    } else if (char === ']') {
                        balance--;
                        if (balance === 0) {
                            endBracket = i;
                            break;
                        }
                    }
                }
            }

            if (endBracket === -1) {
                logger.info('[Blackiya/Gemini] Could not find balanced JSON array');
                return null;
            }

            const jsonStr = cleanedData.substring(startBracket, endBracket + 1);
            const wrapper = JSON.parse(jsonStr);

            if (!Array.isArray(wrapper) || wrapper.length === 0) {
                logger.info('[Blackiya/Gemini] Wrapper is not an array or is empty');
                return null;
            }

            logger.info('[Blackiya/Gemini] Wrapper array length:', wrapper.length);

            // 4. Find conversation data RPC result
            let rpcResult = null;
            let foundRpcId = null;

            for (const item of wrapper) {
                if (Array.isArray(item) && item.length >= 3 && item[0] === 'wrb.fr') {
                    const rpcId = item[1];
                    const payloadStr = item[2];

                    logger.info(`[Blackiya/Gemini] Checking RPC ID: ${rpcId}`);

                    if (typeof payloadStr === 'string') {
                        try {
                            const testPayload = JSON.parse(payloadStr);
                            if (this.isConversationPayload?.(testPayload)) {
                                logger.info(`[Blackiya/Gemini] Found conversation data in RPC ID: ${rpcId}`);
                                rpcResult = item;
                                foundRpcId = rpcId;
                                break;
                            }
                        } catch (_e) {}
                    }
                }
            }

            if (!rpcResult) {
                logger.info('[Blackiya/Gemini] No RPC result with conversation data found');
                return null;
            }

            logger.info(`[Blackiya/Gemini] Using RPC ID: ${foundRpcId}`);

            // 5. Parse the payload
            const payload = JSON.parse(rpcResult[2]);

            // 6. Navigate to conversation data
            const conversationRoot = payload[0]?.[0];
            if (!conversationRoot || !Array.isArray(conversationRoot)) {
                logger.info('[Blackiya/Gemini] Invalid conversation root structure');
                return null;
            }

            // Extract IDs
            const idArray = conversationRoot[0];
            let conversationId = Array.isArray(idArray) ? idArray[0] : null;

            if (conversationId && typeof conversationId === 'string' && conversationId.startsWith('c_')) {
                conversationId = conversationId.slice(2);
            }

            logger.info('[Blackiya/Gemini] Extracted conversation ID:', conversationId);

            // 7. Get title from cache or use default
            const conversationTitle =
                conversationId && conversationTitles.has(conversationId)
                    ? conversationTitles.get(conversationId)!
                    : 'Gemini Conversation';

            logger.info('[Blackiya/Gemini] Looking up title for ID:', conversationId);
            logger.info(
                '[Blackiya/Gemini] Title cache has this ID:',
                conversationId ? conversationTitles.has(conversationId) : false,
            );
            logger.info('[Blackiya/Gemini] Using title:', conversationTitle);

            // 8. Extract messages
            const parsedMessages: any[] = [];

            const extractText = (node: any): string => {
                if (typeof node === 'string') {
                    return node;
                }
                if (Array.isArray(node)) {
                    if (node.length > 0) {
                        if (node.length >= 3 && node[0] === null && typeof node[2] === 'string') {
                            return node[2];
                        }
                        return extractText(node[0]);
                    }
                }
                return '';
            };

            // User message (index 2)
            const userSlot = conversationRoot[2];
            if (userSlot && Array.isArray(userSlot)) {
                const rawUserContent = extractText(userSlot);
                if (rawUserContent) {
                    parsedMessages.push({
                        role: 'user',
                        content: rawUserContent,
                    });
                }
            }

            // Assistant message (index 3)
            const assistantSlot = conversationRoot[3];
            if (assistantSlot && Array.isArray(assistantSlot)) {
                const candidate = assistantSlot[0];
                if (candidate && Array.isArray(candidate)) {
                    const actualCandidate = candidate[0];
                    if (actualCandidate && Array.isArray(actualCandidate)) {
                        let assistantContent = '';

                        // Response text is at index 1
                        const contentNode = actualCandidate[1];
                        if (Array.isArray(contentNode) && contentNode.length > 0) {
                            if (typeof contentNode[0] === 'string') {
                                assistantContent = contentNode[0];
                            }
                        }

                        // Extract reasoning/thoughts (index 37)
                        const thoughts: any[] = [];
                        const reasoningData = actualCandidate[37];

                        if (Array.isArray(reasoningData) && reasoningData.length > 0) {
                            const thinkingText = reasoningData[0]?.[0];

                            if (typeof thinkingText === 'string' && thinkingText.length > 0) {
                                const sections = thinkingText.split(/\n\*\*([^*]+)\*\*\n/);

                                for (let i = 1; i < sections.length; i += 2) {
                                    const title = sections[i]?.trim();
                                    const content = sections[i + 1]?.trim();

                                    if (title && content) {
                                        thoughts.push({
                                            summary: title,
                                            content: content,
                                            chunks: [],
                                            finished: true,
                                        });
                                    }
                                }
                            }
                        }

                        if (assistantContent || thoughts.length > 0) {
                            parsedMessages.push({
                                role: 'assistant',
                                content: assistantContent,
                                thoughts: thoughts.length > 0 ? thoughts : undefined,
                            });
                        }
                    }
                }
            }

            // 9. Build mapping
            const mapping: Record<string, MessageNode> = {};

            // Extract model name from assistantSlot[21] if available
            let modelName = 'gemini-2.0';
            if (conversationRoot[3] && Array.isArray(conversationRoot[3]) && conversationRoot[3].length > 21) {
                const modelSlug = conversationRoot[3][21];
                if (typeof modelSlug === 'string') {
                    modelName = `gemini-${modelSlug.toLowerCase().replace(/\s+/g, '-')}`;
                    logger.info('[Blackiya/Gemini] Extracted model name:', modelName);
                }
            }

            parsedMessages.forEach((msg, index) => {
                const id = `segment-${index}`;

                mapping[id] = {
                    id,
                    message: {
                        id,
                        author: {
                            role: msg.role,
                            name: msg.role === 'user' ? 'User' : 'Gemini',
                            metadata: {},
                        },
                        content: {
                            content_type: msg.thoughts ? 'thoughts' : 'text',
                            parts: [msg.content],
                            thoughts: msg.thoughts,
                        },
                        create_time: Date.now() / 1000,
                        update_time: Date.now() / 1000,
                        status: 'finished_successfully',
                        end_turn: true,
                        weight: 1,
                        metadata: {},
                        recipient: 'all',
                        channel: null,
                    },
                    parent: index === 0 ? null : `segment-${index - 1}`,
                    children: index < parsedMessages.length - 1 ? [`segment-${index + 1}`] : [],
                };
            });

            logger.info(
                '[Blackiya/Gemini] Successfully parsed conversation with',
                Object.keys(mapping).length,
                'messages',
            );

            const conversationData: ConversationData = {
                title: conversationTitle, // Use cached title instead of default
                create_time: Date.now() / 1000,
                update_time: Date.now() / 1000,
                conversation_id: conversationId || 'unknown',
                mapping,
                current_node: `segment-${Math.max(0, parsedMessages.length - 1)}`,
                is_archived: false,
                safe_urls: [],
                blocked_urls: [],
                moderation_results: [],
                plugin_ids: null,
                gizmo_id: null,
                gizmo_type: null,
                default_model_slug: modelName,
            };

            // Store in active conversations map for potential retroactive title updates
            if (conversationId) {
                activeConversations.set(conversationId, conversationData);
            }

            return conversationData;
        } catch (e) {
            logger.error('[Blackiya/Gemini] Failed to parse:', e);
            if (e instanceof Error) {
                logger.error('[Blackiya/Gemini] Error stack:', e.stack);
            }
            return null;
        }
    },

    /**
     * Helper to detect if a payload contains conversation data
     */
    isConversationPayload(payload: any): boolean {
        try {
            if (!Array.isArray(payload) || payload.length === 0) {
                return false;
            }

            const level1 = payload[0];
            if (!Array.isArray(level1) || level1.length === 0) {
                return false;
            }

            const conversationRoot = level1[0];
            if (!Array.isArray(conversationRoot) || conversationRoot.length < 3) {
                return false;
            }

            const idArray = conversationRoot[0];
            if (!Array.isArray(idArray) || idArray.length < 2) {
                return false;
            }

            const firstId = idArray[0];
            if (typeof firstId === 'string' && (firstId.startsWith('c_') || /^[a-f0-9]+$/i.test(firstId))) {
                return true;
            }

            return false;
        } catch {
            return false;
        }
    },

    formatFilename(data: ConversationData): string {
        const title = data.title || 'Gemini_Conversation';
        const sanitizedTitle = sanitizeFilename(title).slice(0, MAX_TITLE_LENGTH);
        const timestamp = generateTimestamp(data.update_time);
        return `${sanitizedTitle}_${timestamp}`;
    },

    getButtonInjectionTarget(): HTMLElement | null {
        const selectors = [
            'header [aria-haspopup="menu"]',
            'header .flex-1.overflow-hidden',
            'header nav',
            '.chat-app-header',
            'header',
            '[role="banner"]',
            'body',
        ];

        for (const selector of selectors) {
            const target = document.querySelector(selector);
            if (target) {
                return (target.parentElement || target) as HTMLElement;
            }
        }
        return null;
    },
};

```

`platforms/grok.test.ts`:

```ts
/**
 * Tests for Grok Platform Adapter
 *
 * TDD tests for conversation ID extraction, API URL matching, and data parsing
 */

import { describe, expect, it, mock } from 'bun:test';

// Mock wxt/browser explicitly to avoid logging errors
const browserMock = {
    storage: {
        local: {
            get: async () => ({}),
            set: async () => {},
        },
    },
    runtime: {
        getURL: () => 'chrome-extension://mock/',
    },
};
mock.module('wxt/browser', () => ({
    browser: browserMock,
}));

import sampleConversation from '@/data/grok/sample_grok_conversation.json';
import sampleHistory from '@/data/grok/sample_grok_history.json';
import { grokAdapter } from '@/platforms/grok';

describe('Grok Platform Adapter', () => {
    describe('extractConversationId', () => {
        it('should extract conversation ID from standard Grok URL', () => {
            const url = 'https://x.com/i/grok?conversation=2013295304527827227';
            const id = grokAdapter.extractConversationId(url);
            expect(id).toBe('2013295304527827227');
        });

        it('should extract conversation ID from URL with additional query parameters', () => {
            const url = 'https://x.com/i/grok?conversation=2013295304527827227&mode=normal';
            const id = grokAdapter.extractConversationId(url);
            expect(id).toBe('2013295304527827227');
        });

        it('should return null for Grok URL without conversation parameter', () => {
            const url = 'https://x.com/i/grok';
            const id = grokAdapter.extractConversationId(url);
            expect(id).toBeNull();
        });

        it('should return null for non-Grok URL', () => {
            const url = 'https://x.com/home';
            const id = grokAdapter.extractConversationId(url);
            expect(id).toBeNull();
        });

        it('should return null for non-x.com domain', () => {
            const url = 'https://twitter.com/i/grok?conversation=123456789';
            const id = grokAdapter.extractConversationId(url);
            expect(id).toBeNull();
        });

        it('should return null for invalid conversation ID format', () => {
            const url = 'https://x.com/i/grok?conversation=invalid-id';
            const id = grokAdapter.extractConversationId(url);
            expect(id).toBeNull();
        });

        it('should return null for very long numeric conversation IDs', () => {
            const url = 'https://x.com/i/grok?conversation=20132953045278272271234567890';
            const id = grokAdapter.extractConversationId(url);
            expect(id).toBeNull(); // Too long (> 20 digits)
        });

        it('should handle minimum length numeric IDs', () => {
            const url = 'https://x.com/i/grok?conversation=1234567890';
            const id = grokAdapter.extractConversationId(url);
            expect(id).toBe('1234567890');
        });
    });

    describe('isPlatformUrl', () => {
        it('should recognize valid Grok URLs', () => {
            expect(grokAdapter.isPlatformUrl('https://x.com/i/grok?conversation=123')).toBe(true);
            expect(grokAdapter.isPlatformUrl('https://x.com/i/grok')).toBe(true);
        });

        it('should reject non-Grok URLs', () => {
            expect(grokAdapter.isPlatformUrl('https://x.com/home')).toBe(false);
            expect(grokAdapter.isPlatformUrl('https://chatgpt.com')).toBe(false);
        });
    });

    describe('apiEndpointPattern', () => {
        it('should match Grok GraphQL conversation endpoint', () => {
            const endpoint =
                'https://x.com/i/api/graphql/6QmFgXuRQyOnW2iJ7nIk7g/GrokConversationItemsByRestId?variables=%7B%22restId%22%3A%222013295304527827227%22%7D';
            expect(grokAdapter.apiEndpointPattern.test(endpoint)).toBe(true);
        });

        it('should match GrokHistory endpoint', () => {
            const endpoint = 'https://x.com/i/api/graphql/9Hyh5D4-WXLnExZkONSkZg/GrokHistory?variables=%7B%7D';
            expect(grokAdapter.apiEndpointPattern.test(endpoint)).toBe(true);
        });

        it('should not match other GraphQL endpoints', () => {
            const endpoint = 'https://x.com/i/api/graphql/abc123/UserByScreenName';
            expect(grokAdapter.apiEndpointPattern.test(endpoint)).toBe(false);
        });

        it('should not match non-API URLs', () => {
            const endpoint = 'https://x.com/i/grok?conversation=123';
            expect(grokAdapter.apiEndpointPattern.test(endpoint)).toBe(false);
        });
    });

    describe('parseInterceptedData - Conversation Data', () => {
        it('should parse valid Grok conversation JSON data from object', () => {
            // Pass as object (TypeScript will accept this as 'any')
            const result = grokAdapter.parseInterceptedData(
                JSON.stringify(sampleConversation),
                'https://x.com/i/api/graphql/test/GrokConversationItemsByRestId',
            );
            expect(result).not.toBeNull();
            expect(result?.conversation_id).toBeDefined();
            expect(result?.mapping).toBeDefined();
        });

        it('should parse valid Grok conversation JSON data from string', () => {
            const jsonString = JSON.stringify(sampleConversation);
            const result = grokAdapter.parseInterceptedData(
                jsonString,
                'https://x.com/i/api/graphql/test/GrokConversationItemsByRestId',
            );
            expect(result).not.toBeNull();
        });

        it('should return null for invalid data', () => {
            const result = grokAdapter.parseInterceptedData(
                JSON.stringify({ invalid: 'data' }),
                'https://x.com/i/api/graphql/test/GrokConversationItemsByRestId',
            );
            expect(result).toBeNull();
        });

        it('should return null for empty conversation items', () => {
            const emptyData = {
                data: {
                    grok_conversation_items_by_rest_id: {
                        items: [],
                    },
                },
            };
            const result = grokAdapter.parseInterceptedData(
                JSON.stringify(emptyData),
                'https://x.com/i/api/graphql/test/GrokConversationItemsByRestId',
            );
            expect(result).toBeNull();
        });

        it('should extract conversation title from first user message', () => {
            const result = grokAdapter.parseInterceptedData(
                JSON.stringify(sampleConversation),
                'https://x.com/i/api/graphql/test/GrokConversationItemsByRestId',
            );
            expect(result?.title).toBeDefined();
            expect(typeof result?.title).toBe('string');
        });

        it('should create proper message tree structure', () => {
            const result = grokAdapter.parseInterceptedData(
                JSON.stringify(sampleConversation),
                'https://x.com/i/api/graphql/test/GrokConversationItemsByRestId',
            );
            expect(result).not.toBeNull();

            const mapping = result!.mapping;
            expect(Object.keys(mapping).length).toBeGreaterThan(0);

            // Check that root exists
            const rootNode = mapping['grok-root'];
            expect(rootNode).toBeDefined();
            expect(rootNode.parent).toBeNull();
            expect(rootNode.message).toBeNull();
        });

        it('should preserve message metadata', () => {
            const result = grokAdapter.parseInterceptedData(
                JSON.stringify(sampleConversation),
                'https://x.com/i/api/graphql/test/GrokConversationItemsByRestId',
            );
            const nodes = Object.values(result!.mapping).filter((n) => n.message !== null);

            for (const node of nodes) {
                expect(node.message?.metadata).toBeDefined();
                expect(node.message?.metadata.grok_mode).toBeDefined();
                expect(node.message?.metadata.sender_type).toBeDefined();
            }
        });

        it('should handle messages with thinking content', () => {
            const result = grokAdapter.parseInterceptedData(
                JSON.stringify(sampleConversation),
                'https://x.com/i/api/graphql/test/GrokConversationItemsByRestId',
            );
            const nodes = Object.values(result!.mapping).filter((n) => n.message?.content.content_type === 'thoughts');

            // If there are thinking messages in the sample
            if (nodes.length > 0) {
                for (const node of nodes) {
                    expect(node.message?.content.thoughts).toBeDefined();
                    expect(Array.isArray(node.message?.content.thoughts)).toBe(true);
                }
            }
        });
    });

    describe('parseInterceptedData - Title Caching', () => {
        it('should parse GrokHistory and cache titles', () => {
            // First, parse the history endpoint (returns null but caches titles)
            const historyResult = grokAdapter.parseInterceptedData(
                JSON.stringify(sampleHistory),
                'https://x.com/i/api/graphql/test/GrokHistory',
            );
            expect(historyResult).toBeNull(); // History endpoint doesn't return ConversationData

            // Then parse a conversation - it should use the cached title
            const conversationResult = grokAdapter.parseInterceptedData(
                JSON.stringify(sampleConversation),
                'https://x.com/i/api/graphql/test/GrokConversationItemsByRestId',
            );

            expect(conversationResult).not.toBeNull();
            // The title should be from the cache if the conversation ID matches
            expect(conversationResult?.title).toBeDefined();
        });

        it('should handle GrokHistory as string', () => {
            const historyString = JSON.stringify(sampleHistory);
            const result = grokAdapter.parseInterceptedData(
                historyString,
                'https://x.com/i/api/graphql/test/GrokHistory',
            );
            expect(result).toBeNull(); // Title endpoints return null
        });

        it('should handle invalid GrokHistory data gracefully', () => {
            const invalidHistory = { data: { invalid: 'structure' } };
            const result = grokAdapter.parseInterceptedData(
                JSON.stringify(invalidHistory),
                'https://x.com/i/api/graphql/test/GrokHistory',
            );
            expect(result).toBeNull();
        });
    });

    describe('formatFilename', () => {
        it('should format filename with title and timestamp', () => {
            const data = {
                title: 'Test Grok Conversation',
                create_time: 1768841980.715,
                update_time: 1768841980.715,
                mapping: {},
                conversation_id: '2013295304527827227',
                current_node: 'node-1',
                moderation_results: [],
                plugin_ids: null,
                gizmo_id: null,
                gizmo_type: null,
                is_archived: false,
                default_model_slug: 'grok-2',
                safe_urls: [],
                blocked_urls: [],
            };

            const filename = grokAdapter.formatFilename(data);

            expect(filename).toContain('Test_Grok_Conversation');
            expect(filename).toMatch(/\d{4}-\d{2}-\d{2}/);
        });

        it('should sanitize special characters in title', () => {
            const data = {
                title: 'Test: Special/Characters\\Here?',
                create_time: 1768841980.715,
                update_time: 1768841980.715,
                mapping: {},
                conversation_id: '2013295304527827227',
                current_node: 'node-1',
                moderation_results: [],
                plugin_ids: null,
                gizmo_id: null,
                gizmo_type: null,
                is_archived: false,
                default_model_slug: 'grok-2',
                safe_urls: [],
                blocked_urls: [],
            };

            const filename = grokAdapter.formatFilename(data);
            expect(filename).not.toMatch(/[:/\\?<>"|*]/);
        });

        it('should handle empty title', () => {
            const data = {
                title: '',
                create_time: 1768841980.715,
                update_time: 1768841980.715,
                mapping: {},
                conversation_id: '2013295304527827227',
                current_node: 'node-1',
                moderation_results: [],
                plugin_ids: null,
                gizmo_id: null,
                gizmo_type: null,
                is_archived: false,
                default_model_slug: 'grok-2',
                safe_urls: [],
                blocked_urls: [],
            };

            const filename = grokAdapter.formatFilename(data);
            expect(filename).toContain('grok_conversation');
        });

        it('should truncate very long titles', () => {
            const longTitle = 'A'.repeat(200);
            const data = {
                title: longTitle,
                create_time: 1768841980.715,
                update_time: 1768841980.715,
                mapping: {},
                conversation_id: '2013295304527827227',
                current_node: 'node-1',
                moderation_results: [],
                plugin_ids: null,
                gizmo_id: null,
                gizmo_type: null,
                is_archived: false,
                default_model_slug: 'grok-2',
                safe_urls: [],
                blocked_urls: [],
            };

            const filename = grokAdapter.formatFilename(data);
            expect(filename.length).toBeLessThan(150);
        });
    });

    describe('conversation data structure validation', () => {
        const result = grokAdapter.parseInterceptedData(
            JSON.stringify(sampleConversation),
            'https://x.com/i/api/graphql/test/GrokConversationItemsByRestId',
        );

        it('should have required top-level fields', () => {
            expect(result).not.toBeNull();
            expect(typeof result?.title).toBe('string');
            expect(typeof result?.create_time).toBe('number');
            expect(typeof result?.update_time).toBe('number');
            expect(typeof result?.conversation_id).toBe('string');
            expect(typeof result?.mapping).toBe('object');
            expect(typeof result?.current_node).toBe('string');
        });

        it('should have valid message nodes', () => {
            expect(result).not.toBeNull();
            const nodes = Object.values(result!.mapping);
            expect(nodes.length).toBeGreaterThan(0);

            for (const node of nodes) {
                expect(node.id).toBeDefined();
                expect(Array.isArray(node.children)).toBe(true);

                if (node.parent !== null) {
                    expect(typeof node.parent).toBe('string');
                    expect(result!.mapping[node.parent]).toBeDefined();
                }
            }
        });

        it('should have messages with correct author roles', () => {
            expect(result).not.toBeNull();
            const messagesWithContent = Object.values(result!.mapping).filter(
                (n): n is MessageNode & { message: Message } => n.message !== null,
            );

            expect(messagesWithContent.length).toBeGreaterThan(0);

            for (const node of messagesWithContent) {
                expect(['user', 'assistant']).toContain(node.message.author.role);
            }
        });

        it('should have proper tree structure', () => {
            expect(result).not.toBeNull();

            // Find root node
            const rootNodes = Object.values(result!.mapping).filter((n) => n.parent === null);
            expect(rootNodes.length).toBe(1);

            // Verify children point to valid nodes
            for (const node of Object.values(result!.mapping)) {
                for (const childId of node.children) {
                    const childNode = result!.mapping[childId];
                    expect(childNode).toBeDefined();
                    expect(childNode.parent).toBe(node.id);
                }
            }
        });

        it('should have current_node pointing to valid node', () => {
            expect(result).not.toBeNull();
            expect(result!.mapping[result!.current_node]).toBeDefined();
        });
    });
});

describe('Grok Platform Adapter - ID Synchronization', () => {
    it('should override conversation ID from URL params when present', () => {
        // Sample URL that has variables with a different restId
        const urlId = '9999999999999999999';
        const variables = JSON.stringify({ restId: urlId });
        const url = `https://x.com/i/api/graphql/test/GrokConversationItemsByRestId?variables=${encodeURIComponent(variables)}`;

        const result = grokAdapter.parseInterceptedData(JSON.stringify(sampleConversation), url);

        expect(result).not.toBeNull();
        expect(result?.conversation_id).toBe(urlId);
    });

    it('should fallback to regex extraction when URL variables are not valid JSON', () => {
        const urlId = '8888888888888888888';
        // Simulating a scenario where variables parsing fails but regex works
        // Note: The regex looks for %22restId%22%3A%22(\d+)%22
        // We construct a URL that has this pattern but broken JSON syntax otherwise
        const url = `https://x.com/i/api/graphql/test?variables={%22restId%22%3A%22${urlId}%22, BROKEN_JSON`;

        const result = grokAdapter.parseInterceptedData(JSON.stringify(sampleConversation), url);

        expect(result).not.toBeNull();
        expect(result?.conversation_id).toBe(urlId);
    });

    it('should use internal conversation ID when no URL restId is present', () => {
        const url = 'https://x.com/i/api/graphql/test/GrokConversationItemsByRestId';

        const result = grokAdapter.parseInterceptedData(JSON.stringify(sampleConversation), url);

        expect(result).not.toBeNull();
        // Should use the ID from the sample data
        // We need to check what the ID is in the sample_grok_conversation.json
        // Based on previous logs, it's likely "2013295304527827227" or similar
        // But reliably we just assert it's NOT empty
        expect(result?.conversation_id).toBeDefined();
        expect(result?.conversation_id.length).toBeGreaterThan(0);
    });
});

```

`platforms/grok.ts`:

```ts
/**
 * Grok Platform Adapter - With Title Support
 *
 * Enhancements:
 * 1. Intercepts GrokHistory API calls to capture conversation titles
 * 2. Caches title mappings (conversationId -> title)
 * 3. Uses cached titles when building ConversationData
 * 4. Retroactively updates active conversations when titles arrive
 */

import type { LLMPlatform } from '@/platforms/types';
import { generateTimestamp, sanitizeFilename } from '@/utils/download';
import { logger } from '@/utils/logger';
import { LRUCache } from '@/utils/lru-cache';
import type { Author, ConversationData, Message, MessageContent, MessageNode } from '@/utils/types';

const MAX_TITLE_LENGTH = 80;

/**
 * Regex pattern to match a valid Grok conversation ID
 * Format: numeric string (e.g., "2013295304527827227")
 */
const CONVERSATION_ID_PATTERN = /^\d{10,20}$/;

/**
 * In-memory cache for conversation titles
 * Maps conversation ID (rest_id) to title
 */
const conversationTitles = new LRUCache<string, string>(50);

/**
 * Track active conversation objects to allow retroactive title updates
 * Maps conversation ID -> ConversationData object reference
 */
const activeConversations = new LRUCache<string, ConversationData>(50);

/**
 * Parse the GrokHistory response to extract conversation titles
 */
function parseTitlesResponse(data: string, url: string): Map<string, string> | null {
    try {
        logger.info('[Blackiya/Grok/Titles] Attempting to parse titles from:', url);

        const parsed = JSON.parse(data);
        const historyData = parsed?.data?.grok_conversation_history;

        if (!historyData || !Array.isArray(historyData.items)) {
            logger.info('[Blackiya/Grok/Titles] No conversation history items found');
            return null;
        }

        const titles = new Map<string, string>();

        for (const item of historyData.items) {
            const restId = item?.grokConversation?.rest_id;
            const title = item?.title;

            if (typeof restId === 'string' && typeof title === 'string') {
                titles.set(restId, title);

                // Retroactively update any active conversation object
                if (activeConversations.has(restId)) {
                    const activeObj = activeConversations.get(restId);
                    if (activeObj && activeObj.title !== title) {
                        activeObj.title = title;
                        logger.info(
                            `[Blackiya/Grok/Titles] Retroactively updated title for active conversation: ${restId} -> "${title}"`,
                        );
                    }
                }
            }
        }

        logger.info(`[Blackiya/Grok/Titles] Extracted ${titles.size} conversation titles`);
        return titles;
    } catch (e) {
        logger.error('[Blackiya/Grok/Titles] Failed to parse titles:', e);
        return null;
    }
}

/**
 * Check if a URL is a GrokHistory (conversation list) endpoint
 */
function isTitlesEndpoint(url: string): boolean {
    const isTitles = url.includes('GrokHistory');
    if (isTitles) {
        logger.info('[Blackiya/Grok/Titles] Detected titles endpoint');
    }
    return isTitles;
}

/**
 * Extract thinking/reasoning content from Grok message
 */

function extractThinkingContent(chatItem: any):
    | Array<{
          summary: string;
          content: string;
          chunks: string[];
          finished: boolean;
      }>
    | undefined {
    // Check if there are deepsearch_headers which contain reasoning steps
    if (Array.isArray(chatItem?.deepsearch_headers)) {
        const thoughts = chatItem.deepsearch_headers.flatMap((header: any) =>
            Array.isArray(header?.steps)
                ? header.steps
                      .filter((step: any) => step?.final_message)
                      .map((step: any) => ({
                          summary: header.header || 'Reasoning',
                          content: step.final_message,
                          chunks: [],
                          finished: true,
                      }))
                : [],
        );

        return thoughts.length > 0 ? thoughts : undefined;
    }

    return undefined;
}

/**
 * Determine sender type and create Author object
 */
function createAuthor(senderType: string): Author {
    if (senderType === 'User') {
        return {
            role: 'user',
            name: 'User',
            metadata: {},
        };
    }

    // Agent (Grok AI)
    return {
        role: 'assistant',
        name: 'Grok',
        metadata: {},
    };
}

/**
 * Parse Grok API response into ConversationData
 */
// biome-ignore lint/complexity/noExcessiveCognitiveComplexity: Complex parsing logic required for platform
function parseGrokResponse(data: any, conversationIdOverride?: string): ConversationData | null {
    try {
        const conversationData = data?.data?.grok_conversation_items_by_rest_id;
        if (!conversationData) {
            logger.info('[Blackiya/Grok] No conversation data found in response');
            return null;
        }

        const items = conversationData.items;
        if (!Array.isArray(items) || items.length === 0) {
            logger.info('[Blackiya/Grok] No conversation items found');
            return null;
        }

        // Extract conversation metadata
        const _isPinned = conversationData.is_pinned || false;
        const _cursor = conversationData.cursor || '';

        // Build the conversation mapping
        const mapping: Record<string, MessageNode> = {};
        let conversationId = '';
        let conversationTitle = 'Grok Conversation';
        let createTime = Date.now() / 1000;
        let updateTime = Date.now() / 1000;

        // Create root node
        const rootId = 'grok-root';
        mapping[rootId] = {
            id: rootId,
            message: null,
            parent: null,
            children: [],
        };

        let previousNodeId = rootId;

        // Process each chat item
        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            const chatItemId = item.chat_item_id;
            const createdAtMs = item.created_at_ms;
            const grokMode = item.grok_mode || 'Normal';
            const message = item.message || '';
            const senderType = item.sender_type || 'Agent';
            const isPartial = item.is_partial || false;

            // Extract conversation ID from first message
            if (i === 0) {
                // Priority 1: Use the override which comes from the URL restId
                if (conversationIdOverride) {
                    conversationId = conversationIdOverride;
                }
                // Priority 2: Use chat_item_id as fallback, though it may trigger cache mismatches
                else if (chatItemId) {
                    conversationId = chatItemId;
                }
            }

            // Extract title from first user message if available (fallback)
            if (i === 0 && senderType === 'User' && message && !conversationTitles.has(conversationId)) {
                const firstLine = message.split('\n')[0];
                if (firstLine && firstLine.length > 0 && firstLine.length < 100) {
                    conversationTitle = firstLine;
                }
            }

            // Update timestamps
            if (createdAtMs) {
                const timestamp = createdAtMs / 1000;
                if (i === 0) {
                    createTime = timestamp;
                }
                updateTime = Math.max(updateTime, timestamp);
            }

            // Create message content
            const thoughts = extractThinkingContent(item);
            const contentType = thoughts ? 'thoughts' : 'text';

            const content: MessageContent = {
                content_type: contentType,
                parts: [message],
                thoughts: thoughts,
            };

            // Create message
            const messageObj: Message = {
                id: chatItemId,
                author: createAuthor(senderType),
                create_time: createdAtMs ? createdAtMs / 1000 : null,
                update_time: null,
                content: content,
                status: isPartial ? 'in_progress' : 'finished_successfully',
                end_turn: !isPartial,
                weight: 1,
                metadata: {
                    grok_mode: grokMode,
                    sender_type: senderType,
                    is_partial: isPartial,
                    thinking_trace: item.thinking_trace || '',
                    ui_layout: item.ui_layout || {},
                },
                recipient: 'all',
                channel: null,
            };

            // Create message node
            const nodeId = chatItemId;
            mapping[nodeId] = {
                id: nodeId,
                message: messageObj,
                parent: previousNodeId,
                children: [],
            };

            // Update parent's children
            if (mapping[previousNodeId]) {
                mapping[previousNodeId].children.push(nodeId);
            }

            previousNodeId = nodeId;
        }

        // Get the last node ID
        const lastNodeId = items.length > 0 ? items[items.length - 1].chat_item_id : rootId;

        // Check if we have a cached title for this conversation
        if (conversationId && conversationTitles.has(conversationId)) {
            conversationTitle = conversationTitles.get(conversationId)!;
            logger.info('[Blackiya/Grok] Using cached title:', conversationTitle);
        }

        const result: ConversationData = {
            title: conversationTitle,
            create_time: createTime,
            update_time: updateTime,
            mapping: mapping,
            conversation_id: conversationId,
            current_node: lastNodeId,
            moderation_results: [],
            plugin_ids: null,
            gizmo_id: null,
            gizmo_type: null,
            is_archived: false,
            default_model_slug: 'grok-2',
            safe_urls: [],
            blocked_urls: [],
        };

        // Store in active conversations map for potential retroactive title updates
        if (conversationId) {
            activeConversations.set(conversationId, result);
        }

        logger.info('[Blackiya/Grok] Successfully parsed conversation with', Object.keys(mapping).length, 'nodes');
        return result;
    } catch (e) {
        logger.error('[Blackiya/Grok] Failed to parse conversation:', e);
        if (e instanceof Error) {
            logger.error('[Blackiya/Grok] Error stack:', e.stack);
        }
        return null;
    }
}

/**
 * Grok Platform Adapter
 *
 * Supports x.com Grok conversations
 */
export const grokAdapter: LLMPlatform = {
    name: 'Grok',

    urlMatchPattern: 'https://x.com/i/grok*',

    // Match BOTH the conversation endpoint AND the history endpoint
    apiEndpointPattern: /\/i\/api\/graphql\/[^/]+\/(GrokConversationItemsByRestId|GrokHistory)/,

    /**
     * Check if a URL belongs to Grok
     */
    isPlatformUrl(url: string): boolean {
        return url.includes('x.com/i/grok');
    },

    /**
     * Extract conversation ID from Grok URL
     *
     * Supports:
     * - https://x.com/i/grok?conversation={id}
     * - https://x.com/i/grok?conversation={id}&other=params
     *
     * @param url - The current page URL
     * @returns The conversation ID or null if not found/invalid
     */
    extractConversationId(url: string): string | null {
        try {
            const urlObj = new URL(url);

            // Validate hostname
            if (urlObj.hostname !== 'x.com') {
                return null;
            }

            // Check if path is /i/grok
            if (!urlObj.pathname.startsWith('/i/grok')) {
                return null;
            }

            // Extract conversation ID from query parameter
            const conversationId = urlObj.searchParams.get('conversation');
            if (!conversationId) {
                return null;
            }

            // Validate format (numeric string)
            if (!CONVERSATION_ID_PATTERN.test(conversationId)) {
                return null;
            }

            return conversationId;
        } catch {
            return null;
        }
    },

    /**
     * Parse intercepted Grok API response
     *
     * @param data - Raw text or parsed object
     * @param url - The API endpoint URL
     */
    // biome-ignore lint/complexity/noExcessiveCognitiveComplexity: Centralized logic for parsing Grok data
    parseInterceptedData(data: string | any, url: string): ConversationData | null {
        // Check if this is a titles endpoint
        if (isTitlesEndpoint(url)) {
            const dataStr = typeof data === 'string' ? data : JSON.stringify(data);
            const titles = parseTitlesResponse(dataStr, url);
            if (titles) {
                // Merge into global cache
                for (const [id, title] of titles) {
                    conversationTitles.set(id, title);
                }
                logger.info(`[Blackiya/Grok] Title cache now contains ${conversationTitles.size} entries`);
            } else {
                logger.info('[Blackiya/Grok/Titles] Failed to extract titles from this response');
            }
            // Don't return ConversationData for title endpoints
            return null;
        }

        // Otherwise, parse as conversation data
        try {
            const parsed = typeof data === 'string' ? JSON.parse(data) : data;

            // Extract restId from URL if possible to ensure we use the same ID as the cache
            let conversationIdFromUrl: string | undefined;
            if (url) {
                try {
                    const urlObj = new URL(url);
                    const variablesStr = urlObj.searchParams.get('variables');
                    if (variablesStr) {
                        const variables = JSON.parse(variablesStr);
                        if (variables?.restId) {
                            conversationIdFromUrl = variables.restId;
                        }
                    }
                } catch {
                    // Fallback to regex
                    const match = url.match(/%22restId%22%3A%22(\d+)%22/);
                    if (match?.[1]) {
                        conversationIdFromUrl = match[1];
                    }
                }
            }

            return parseGrokResponse(parsed, conversationIdFromUrl);
        } catch (e) {
            logger.error('[Blackiya/Grok] Failed to parse data:', e);
            return null;
        }
    },

    /**
     * Format a filename for the downloaded JSON
     *
     * Format: {sanitized_title}_{YYYY-MM-DD_HH-MM-SS}
     *
     * @param data - The conversation data
     * @returns A sanitized filename (without .json extension)
     */
    formatFilename(data: ConversationData): string {
        let title = data.title || '';

        // If no title, use a default with part of conversation ID
        if (!title.trim()) {
            const idPart =
                data.conversation_id && data.conversation_id.length >= 8
                    ? data.conversation_id.slice(0, 8)
                    : data.conversation_id || 'unknown';
            title = `grok_conversation_${idPart}`;
        }

        // Sanitize and truncate title
        let sanitizedTitle = sanitizeFilename(title);
        if (sanitizedTitle.length > MAX_TITLE_LENGTH) {
            sanitizedTitle = sanitizedTitle.slice(0, MAX_TITLE_LENGTH);
        }

        // Generate timestamp from update_time or create_time
        const timestamp = generateTimestamp(data.update_time || data.create_time);

        return `${sanitizedTitle}_${timestamp}`;
    },

    /**
     * Find injection target in Grok UI
     */
    getButtonInjectionTarget(): HTMLElement | null {
        const selectors = ['[data-testid="grok-header"]', '[role="banner"]', 'header nav', 'header', 'body'];

        for (const selector of selectors) {
            const target = document.querySelector(selector);
            if (target) {
                return (target.parentElement || target) as HTMLElement;
            }
        }
        return null;
    },
};

```

`platforms/types.ts`:

```ts
/**
 * Platform adapter interface for LLM providers
 *
 * This interface allows the extension to be extensible to multiple LLM platforms
 * (ChatGPT, Gemini, Grok, etc.) by implementing a common contract.
 *
 * @module platforms/types
 */

import type { ConversationData } from '../utils/types';

/**
 * Interface that all LLM platform adapters must implement
 */
export interface LLMPlatform {
    /** Display name of the platform (e.g., "ChatGPT", "Gemini") */
    name: string;

    /** URL match pattern for the content script (e.g., "https://chatgpt.com/*") */
    urlMatchPattern: string;

    /** Regex pattern to match the conversation API endpoint */
    apiEndpointPattern: RegExp;

    /**
     * Check if a URL belongs to this platform
     */
    isPlatformUrl(url: string): boolean;

    /**
     * Extract the conversation ID from the current page URL
     * @param url - The current page URL
     * @returns The conversation ID or null if not found
     */
    extractConversationId(url: string): string | null;

    /**
     * Parse raw intercepted data into standardized ConversationData
     * @param data - The raw response data (as string)
     * @param url - The URL of the intercepted request
     * @returns Standardized conversation data or null if parsing fails
     */
    parseInterceptedData(data: string, url: string): ConversationData | null;

    /**
     * Format the filename for the downloaded JSON file
     * @param data - The conversation data
     * @returns A sanitized filename (without extension)
     */
    formatFilename(data: ConversationData): string;

    /**
     * Find the DOM element where the save button should be injected
     */
    getButtonInjectionTarget(): HTMLElement | null;

    /**
     * Optional helper to check if a payload contains conversation data
     * Useful for platforms with complex/nested responses (like Gemini)
     */
    isConversationPayload?: (payload: any) => boolean;
}

```

`reviews/synthesis.md`:

```md
# Synthesized Code Review & Action Plan

This document synthesizes feedback from multiple AI agent reviews (Claude Sonnet 4.5, GPT-5.2, Geminis, Groks, etc.) regarding the **Blackiya** browser extension codebase. It categorizes issues, evaluates their validity, and outlines a concrete plan for remediation.

---

## 1. üèó Architecture & Design

### 1.1 `platform-runner.ts` has too much context.
**Feedback:** Nearly every reviewer identified `utils/platform-runner.ts` as monolithic. It handles UI injection, event listening, caching, navigation detection, and data orchestration.
**Verdict:** **AGREE**.
**Why:** This violates SRP and makes the core logic fragile. Changing UI styling shouldn't risk breaking data interception.
**Action:** Refactor into specialized managers:
- `ButtonManager`: Handles creation, styling, and injection of the UI.
- `CaptureManager` (or `InterceptionManager`): Handles message listening, parsing, and data caching.
- `NavigationObserver`: Handles DOM watching and URL changes.
- `PlatformOrchestrator`: Ties them together.

### 1.2 Factory Pattern Efficiency
**Feedback:** The current `factory.ts` (implied or actual) uses linear search `O(n)` to find adapters.
**Verdict:** **AGREE (Low Priority)**.
**Why:** While `O(n)` is negligible for <10 platforms, a Map-based lookup (by domain) is cleaner and more scalable as we add more providers.
**Action:** Implement a `PlatformRegistry` using a Map keyed by hostname/domain.

### 1.3 Over-Engineering Claims (Clean Architecture)
**Feedback:** Some reviews (specifically "OpenAI GPT-5.2") suggested a full "Ports & Adapters" / "Clean Architecture" with `core/domain`, `infra/fs`, etc.
**Verdict:** **DISAGREE / DEFER**.
**Why:** This is a browser extension, not a backend microservice. While distinct layers are good, a rigid enterprise directory structure is overengineering for the current scope. We will stick to `entrypoints`, `platforms`, and `utils` but ensure internally they have better separation (as per 1.1).

---

## 2. üî¥ Critical Bugs & Reliability

### 2.1 Memory Leaks in Caches
**Feedback:** Adapters (Gemini, Grok) and the runner use global `Map` objects (`activeConversations`, `conversationTitles`) that never clear.
**Verdict:** **AGREE (CRITICAL)**.
**Why:** Long-running browser sessions will accumulate unbounded memory.
**Action:** Implement a generic `LRUCache` utility and use it for all conversation/title stores.

### 2.2 Global Interceptor Pollution
**Feedback:** `interceptor.content.ts` patches `window.fetch` and `XMLHttpRequest` but never restores them on unload/extension disable.
**Verdict:** **AGREE**.
**Why:** This can cause weird behavior if the extension is reloaded or disabled without a page refresh (though technically difficult in Chrome extensions to "undo" perfectly, we should try).
**Action:** Add cleanup logic where possible, or at least a "marker" to prevent double-patching if the script re-runs.

### 2.3 Race Conditions in Message Interception
**Feedback:** `window.postMessage` might fire before the listener is ready, or the page might navigate away before `response.text()` resolves.
**Verdict:** **AGREE**.
**Why:** Network/Async races are common.
**Action:** Add basic error handling and timeouts to the interception logic.

---

## 3. üõ° Security

### 3.1 XSS in Button Injection
**Feedback:** `button.innerHTML` is used with SVG strings.
**Verdict:** **AGREE**.
**Why:** While currently static, using `innerHTML` is a bad habit and flags security scanners.
**Action:** Use `document.createElementNS` for SVGs or a safe DOM builder pattern.

### 3.2 `postMessage` Origin
**Feedback:** `window.postMessage(..., '*')` allows any origin to read the message.
**Verdict:** **AGREE**.
**Why:** Malicious iframes or scripts could theoretically spy on the intercepted data.
**Action:** Restrict target origin to `window.location.origin`.

---

## 4. ‚ö° Performance

### 4.1 Expensive MutationObserver
**Feedback:** Observing `document.body` with `subtree: true` fires on every DOM change.
**Verdict:** **AGREE**.
**Why:** Performance killer on complex SPAs.
**Action:** Target specific containers (e.g., `header`, `#main-content`) per platform, or rely more on URL polling/History API hooking if possible. Debounce the callback significantly.

### 4.2 Interceptor Memory Usage
**Feedback:** `response.clone().text()` reads the entire body into memory for *every* request matching the pattern.
**Verdict:** **AGREE**.
**Why:** Long conversations can be MBs in size.
**Action:** Check `Content-Length` header (if available) or implement a size limit before cloning.

### 4.3 Synchronous Storage I/O
**Feedback:** `logger` reads/writes the entire log array from `chrome.storage.local` on every entry.
**Verdict:** **AGREE**.
**Why:** `O(n)` operation on every log is terrible for performance.
**Action:** Implement a "Log Buffer" that flushes to storage periodically (e.g., every 5 seconds or 50 logs).

---

## 5. üßë‚Äçüíª Code Quality & Maintainability

### 5.1 Complexity in Parsers ("Arrow Code")
**Feedback:** Gemini and Grok parsers have deep nesting and high cognitive complexity.
**Verdict:** **AGREE**.
**Why:** Hard to read, debug, and test.
**Action:** Extract logic into small, named helper functions (e.g., `extractGeminiTitle`, `parseGrokMessage`).

### 5.2 Type Safety
**Feedback:** Overuse of `any` in parsers; lack of runtime validation (Zod).
**Verdict:** **AGREE (Partially)**.
**Why:** `any` is risky. Zod adds bundle size overhead.
**Action:** Use proper TypeScript interfaces and Type Guards (`isGrokResponse`) instead of full Zod validation to keep it lightweight but safe.

---

## ‚úÖ Next Steps (Prioritized)

We will tackle these in the following order:

1.  **Security & Safety Fixes**:
    *   Fix `postMessage` origin (`*` -> `window.location.origin`).
    *   Replace `innerHTML` with `createElementNS` in button injection.
    *   Add idempotent guard to interceptor (prevent double-patching).

2.  **Memory & Caching**:
    *   Implement `LRUCache<K, V>` utility.
    *   Replace `Map` in `grok.ts`, `gemini.ts`, and `platform-runner.ts` with `LRUCache`.

3.  **Architecture Refactor (The Big Split)**:
    *   Split `platform-runner.ts` into `ButtonManager`, `InterceptionManager`, and `NavigationObserver`.
    *   Ensure strict separation of concerns.

4.  **Logging Optimization**:
    *   Implement `LogBuffer` in `utils/logger.ts` / `logs-storage.ts` to batch storage writes.
    *   Add log rotation (cap max logs definitely).

5.  **Performance Tuning**:
    *   Optimize `MutationObserver` to target specific elements if possible, or heavily debounce.
    *   Add size checks to interceptor cloning.

6.  **Code Cleanup**:
    *   Refactor Gemini/Grok parsers to reduce nesting complexity.
    *   Refactor `factory.ts` to use a Map-based registry.

---

## 6. üìù Implementation Summary (Diffs for Review)

This section details the actual changes implemented based on the above plan.

### 6.1 Security & Safety Fixes
**File:** `entrypoints/interceptor.content.ts`
**Change:** Restricted `postMessage` origin and added idempotency guard.

```typescript
// BEFORE
window.addEventListener('message', (event) => {
    window.postMessage({ type: 'LLM_CAPTURE', ... }, '*');
});

// AFTER
if ((window as any).__BLACKIYA_INTERCEPTED__) return;
(window as any).__BLACKIYA_INTERCEPTED__ = true;

window.addEventListener('message', (event) => {
    if (event.origin !== window.location.origin) return;
    window.postMessage({ type: 'LLM_CAPTURE', ... }, window.location.origin);
});
```

### 6.2 Memory Optimization (LRUCache)
**File:** `utils/lru-cache.ts` (New Utility)
**Change:** Introduced generic LRU Cache to replace unbounded Maps.

```typescript
export class LRUCache<K, V> {
    private capacity: number;
    private cache: Map<K, V>;

    constructor(capacity: number) {
        this.capacity = capacity;
        this.cache = new Map();
    }

    set(key: K, value: V): void {
        if (this.cache.size >= this.capacity) {
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }
        this.cache.set(key, value);
    }
}
```

### 6.3 Architecture Refactor
**File:** `utils/platform-runner.ts`
**Change:** Decomposed monolithic logic into specialized managers.

**New Structure:**
1.  **`utils/ui/button-manager.ts`**: Handles button DOM, styling, loading states.
2.  **`utils/managers/interception-manager.ts`**: Listens to messages, calls adapter parsers, manages data cache.
3.  **`utils/managers/navigation-manager.ts`**: Wraps `MutationObserver` and History API hooks.
4.  **`utils/platform-runner.ts`**: (Orchestrator, reduced to ~100 lines)

```typescript
// platform-runner.ts (New)
export function runPlatform() {
    const buttonManager = new ButtonManager(handleSave);
    const interceptionManager = new InterceptionManager(onData);
    const navigationManager = new NavigationManager(onNav);

    interceptionManager.start();
    navigationManager.start();
}
```

### 6.4 XSS Prevention (ButtonManager)
**File:** `utils/ui/button-manager.ts`
**Change:** Replaced `innerHTML` with `createElementNS` for safer SVG injection.

```typescript
// BEFORE (in platform-runner.ts)
button.innerHTML = '<svg>...</svg><span>Save</span>';

// AFTER (in ButtonManager)
const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
svg.appendChild(path);
button.appendChild(svg);
```

### 6.5 Circular Dependency Fix
**File:** `platforms/factory.ts`
**Change:** Implemented lazy loading for platform adapters.

```typescript
// BEFORE
import { grokAdapter } from './grok'; // Circular dependency if grok imports factory
const PLATFORMS = [grokAdapter, ...];

// AFTER
function getPlatforms() {
    return [grokAdapter, ...]; // Lazy evaluation
}
```

### 6.6 Code Cleanup
**Files:** `utils/managers/navigation-manager.ts`, `platforms/grok.test.ts`, `utils/ui/button-manager.ts`
**Change:** Removed unused code, imports, and redundant wrapper functions.

- **NavigationManager**: Removed redundant `handleNavigationChange` wrapper; now directly uses `onNavigationChange`.
- **Grok Tests**: Removed unused `join` and `beforeAll` imports; added global logger mock.
- **ButtonManager**: Removed unused `adapter` property and `conversationId` parameter from `createButton`.
- **Types**: Removed unused `ExtensionMessage` and `ExtensionResponse` types.
- **Test Setup**: Cleaned up unused imports and biome suppressions.

```

`test-setup.ts`:

```ts
import { mock } from 'bun:test';
import { GlobalRegistrator } from '@happy-dom/global-registrator';

GlobalRegistrator.register();

// Mock wxt/browser
const storageMock = {
    local: {
        get: async () => ({}),
        set: async () => {},
        remove: async () => {},
    },
};

const browserMock = {
    storage: storageMock,
    runtime: {
        getURL: (path: string) => `chrome-extension://mock/${path}`,
    },
};

mock.module('wxt/browser', () => ({
    browser: browserMock,
}));

(global as any).browser = browserMock;

// Mock logger globally to prevent storage writes during tests
mock.module('@/utils/logger', () => ({
    logger: {
        info: () => {},
        warn: () => {},
        error: () => {},
        debug: () => {},
    },
}));

```

`utils/download.test.ts`:

```ts
/**
 * Tests for Download Utilities
 *
 * TDD tests for filename sanitization and timestamp generation
 */

import { describe, expect, it } from 'bun:test';
import { generateTimestamp, sanitizeFilename } from '@/utils/download';

describe('Download Utilities', () => {
    describe('sanitizeFilename', () => {
        it('should replace spaces with underscores', () => {
            const result = sanitizeFilename('Hello World');
            expect(result).toBe('Hello_World');
        });

        it('should remove invalid filesystem characters', () => {
            const result = sanitizeFilename('Test: File/Name\\Here?');
            expect(result).toBe('Test_FileNameHere');
        });

        it('should remove angle brackets and quotes', () => {
            const result = sanitizeFilename('File<with>quotes"and|pipes');
            expect(result).toBe('Filewithquotesandpipes');
        });

        it('should remove asterisks', () => {
            const result = sanitizeFilename('File*with*stars');
            expect(result).toBe('Filewithstars');
        });

        it('should handle empty string', () => {
            const result = sanitizeFilename('');
            expect(result).toBe('untitled');
        });

        it('should handle string with only invalid characters', () => {
            const result = sanitizeFilename('???:::***');
            expect(result).toBe('untitled');
        });

        it('should trim leading and trailing whitespace', () => {
            const result = sanitizeFilename('  Hello World  ');
            expect(result).toBe('Hello_World');
        });

        it('should collapse multiple underscores', () => {
            const result = sanitizeFilename('Hello   World');
            expect(result).toBe('Hello_World');
        });

        it('should handle unicode characters', () => {
            const result = sanitizeFilename('Êó•Êú¨Ë™û Title');
            expect(result).toBe('Êó•Êú¨Ë™û_Title');
        });

        it('should handle emojis', () => {
            const result = sanitizeFilename('Test üî• Title');
            expect(result).toBe('Test_üî•_Title');
        });
    });

    describe('generateTimestamp', () => {
        it('should return ISO-like date format', () => {
            const timestamp = generateTimestamp();
            // Format: YYYY-MM-DD_HH-MM-SS
            expect(timestamp).toMatch(/^\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2}$/);
        });

        it('should generate unique timestamps for different times', () => {
            const _timestamp1 = generateTimestamp();
            // Wait a tiny bit (in practice these would be different)
            const timestamp2 = generateTimestamp();
            // They should be the same format
            expect(timestamp2).toMatch(/^\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2}$/);
        });

        it('should create timestamp from unix epoch', () => {
            const unixTime = 1768670166.492617;
            const timestamp = generateTimestamp(unixTime);
            // Should be a valid date string
            expect(timestamp).toMatch(/^\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2}$/);
        });
    });
});

```

`utils/download.ts`:

```ts
/**
 * Download Utilities
 *
 * Helper functions for downloading JSON files and filename handling
 *
 * @module utils/download
 */

/**
 * Sanitize a string for use as a filename
 *
 * Removes or replaces characters that are invalid in file systems:
 * - Replaces spaces with underscores
 * - Removes: / \ : * ? " < > |
 * - Collapses multiple underscores
 * - Trims whitespace
 *
 * @param filename - The raw filename string
 * @returns A sanitized filename safe for use on all major file systems
 */
export function sanitizeFilename(filename: string): string {
    if (!filename || filename.trim().length === 0) {
        return 'untitled';
    }

    const sanitized = filename
        .trim()
        // Replace spaces with underscores
        .replace(/\s+/g, '_')
        // Remove invalid filesystem characters: / \ : * ? " < > |
        .replace(/[/\\:*?"<>|]/g, '')
        // Collapse multiple underscores
        .replace(/_+/g, '_')
        // Remove leading/trailing underscores
        .replace(/^_+|_+$/g, '');

    // If after sanitization we have an empty string, return 'untitled'
    if (sanitized.length === 0) {
        return 'untitled';
    }

    return sanitized;
}

/**
 * Generate a timestamp string for filenames
 *
 * @param unixTime - Optional Unix timestamp (seconds since epoch). If not provided, uses current time.
 * @returns A timestamp string in format: YYYY-MM-DD_HH-MM-SS
 */
export function generateTimestamp(unixTime?: number): string {
    const date = typeof unixTime === 'number' ? new Date(unixTime * 1000) : new Date();

    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');

    return `${year}-${month}-${day}_${hours}-${minutes}-${seconds}`;
}

/**
 * Download data as a JSON file using blob URL
 *
 * @param data - The data to download as JSON
 * @param filename - The filename (without .json extension)
 */
export function downloadAsJSON(data: unknown, filename: string): void {
    const jsonString = JSON.stringify(data, null, 2);
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);

    const link = document.createElement('a');
    link.href = url;
    link.download = `${filename}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    // Clean up the blob URL
    URL.revokeObjectURL(url);
}

```

`utils/logger.ts`:

```ts
import { type ILogObj, Logger } from 'tslog';
import { browser } from 'wxt/browser';
import { type LogEntry, logsStorage } from './logs-storage';

/**
 * Log levels supported by the extension
 */
export type LogLevel = 'debug' | 'info' | 'warn' | 'error';

/**
 * Determine the current execution context
 */
function getContext(): 'background' | 'content' | 'popup' {
    if (typeof window === 'undefined') {
        return 'background';
    }
    if (location.protocol === 'chrome-extension:' && location.pathname.includes('popup')) {
        return 'popup';
    }
    // Content scripts run in a tab
    if (location.protocol.startsWith('http')) {
        return 'content';
    }

    return 'background'; // Default to background if unsure
}

/**
 * Extension Logger
 *
 * A singleton logger instance that routes logs to both the console (for dev)
 * and persistent storage (for user export).
 */
class ExtensionLogger {
    private logger: Logger<ILogObj>;
    private static instance: ExtensionLogger;
    private context: 'background' | 'content' | 'popup';

    private constructor() {
        this.context = getContext();

        this.logger = new Logger({
            name: 'Blackiya',
            minLevel: 3, // Default to INFO
            hideLogPositionForProduction: true,
            type: 'json',
        });

        // Attach Transport for Persistence
        this.logger.attachTransport((logObj) => {
            this.handleTransport(logObj);
        });
    }

    private handleTransport(logObj: ILogObj) {
        // Convert tslog level ID to string
        // 0: silly, 1: trace, 2: debug, 3: info, 4: warn, 5: error, 6: fatal
        const meta = (logObj as any)._meta;
        const levelId = meta ? meta.logLevelId : 3;

        const levelMap: Record<number, string> = { 2: 'debug', 3: 'info', 4: 'warn' };
        const level = levelId >= 5 ? 'error' : (levelMap[levelId] ?? 'info');

        // Construct standardized entry
        const entry: LogEntry = {
            timestamp: new Date().toISOString(),
            level: level,
            message: logObj[0] as string, // tslog puts the first arg as message usually
            data: Object.keys(logObj)
                .filter((k) => !Number.isNaN(Number(k)) && k !== '0')
                .map((k) => logObj[k]), // Extract other args
            context: this.context,
        };

        // If in Background context, save directly
        if (this.context === 'background') {
            logsStorage.saveLog(entry).catch((err) => console.error('Logger failed to save:', err));
        } else {
            // In Content Script or Popup, assume we can send message
            // We use a try-catch because sending messages might fail during unload
            try {
                browser.runtime
                    .sendMessage({
                        type: 'LOG_ENTRY',
                        payload: entry,
                    })
                    .catch(() => {
                        // Ignore errors if background is unreachable (e.g. extension updating)
                    });
            } catch (_e) {
                // Squelch
            }
        }
    }

    public static getInstance(): ExtensionLogger {
        if (!ExtensionLogger.instance) {
            ExtensionLogger.instance = new ExtensionLogger();
        }
        return ExtensionLogger.instance;
    }

    public debug(message: string, ...args: unknown[]) {
        this.logger.debug(message, ...args);
    }

    public info(message: string, ...args: unknown[]) {
        this.logger.info(message, ...args);
    }

    public warn(message: string, ...args: unknown[]) {
        this.logger.warn(message, ...args);
    }

    public error(message: string, ...args: unknown[]) {
        this.logger.error(message, ...args);
    }

    public setLevel(level: LogLevel) {
        let minLevel = 3;
        switch (level) {
            case 'debug':
                minLevel = 2;
                break;
            case 'info':
                minLevel = 3;
                break;
            case 'warn':
                minLevel = 4;
                break;
            case 'error':
                minLevel = 5;
                break;
        }
        this.logger.settings.minLevel = minLevel;
    }
}

export const logger = ExtensionLogger.getInstance();

```

`utils/logs-storage.ts`:

```ts
import { browser } from 'wxt/browser';

export interface LogEntry {
    timestamp: string;
    level: string;
    message: string;
    data?: any[];
    context: 'background' | 'content' | 'popup' | 'unknown';
}

const MAX_LOGS = 1000;
const STORAGE_KEY = 'logs';

export const logsStorage = {
    /**
     * Append a log entry to storage.
     * Implements a rolling buffer to prevent exceeding storage limits.
     */
    async saveLog(entry: LogEntry): Promise<void> {
        try {
            // We use raw browser.storage.local
            // For a high-frequency logger, reading the whole array, appending, and writing back is slow.
            // But sufficient for this use case.

            const result = await browser.storage.local.get(STORAGE_KEY);
            const logs: LogEntry[] = (result[STORAGE_KEY] as LogEntry[]) || [];

            logs.push(entry);

            // Rotate if too large
            if (logs.length > MAX_LOGS) {
                logs.splice(0, logs.length - MAX_LOGS);
            }

            await browser.storage.local.set({ [STORAGE_KEY]: logs });
        } catch (e) {
            console.error('Failed to save log', e);
        }
    },

    /**
     * Retrieve all stored logs
     */
    async getLogs(): Promise<LogEntry[]> {
        const result = await browser.storage.local.get(STORAGE_KEY);
        return (result[STORAGE_KEY] as LogEntry[]) || [];
    },

    /**
     * Clear all logs
     */
    async clearLogs(): Promise<void> {
        await browser.storage.local.remove(STORAGE_KEY);
    },
};

```

`utils/lru-cache.test.ts`:

```ts
import { describe, expect, it } from 'bun:test';
import { LRUCache } from './lru-cache';

describe('LRUCache', () => {
    it('should store and retrieve values', () => {
        const cache = new LRUCache<string, number>(3);
        cache.set('a', 1);
        expect(cache.get('a')).toBe(1);
    });

    it('should evict oldest item when overflow occurs', () => {
        const cache = new LRUCache<string, number>(2);
        cache.set('a', 1);
        cache.set('b', 2);
        cache.set('c', 3); // Should evict 'a'

        expect(cache.has('a')).toBe(false);
        expect(cache.get('b')).toBe(2);
        expect(cache.get('c')).toBe(3);
        expect(cache.size).toBe(2);
    });

    it('should refresh item position on access (get)', () => {
        const cache = new LRUCache<string, number>(2);
        cache.set('a', 1);
        cache.set('b', 2);

        // Access 'a', making 'b' the oldest
        cache.get('a');

        cache.set('c', 3); // Should evict 'b'

        expect(cache.has('b')).toBe(false);
        expect(cache.has('a')).toBe(true);
        expect(cache.has('c')).toBe(true);
    });

    it('should refresh item position on update (set)', () => {
        const cache = new LRUCache<string, number>(2);
        cache.set('a', 1);
        cache.set('b', 2);

        // Update 'a', making 'b' the oldest
        cache.set('a', 10);

        cache.set('c', 3); // Should evict 'b'

        expect(cache.has('b')).toBe(false);
        expect(cache.get('a')).toBe(10);
        expect(cache.get('c')).toBe(3);
    });

    it('should throw error for invalid size', () => {
        expect(() => new LRUCache(0)).toThrow();
        expect(() => new LRUCache(-1)).toThrow();
    });

    it('should support clearing the cache', () => {
        const cache = new LRUCache<string, number>(3);
        cache.set('a', 1);
        cache.set('b', 2);
        cache.clear();
        expect(cache.size).toBe(0);
        expect(cache.has('a')).toBe(false);
    });
});

```

`utils/lru-cache.ts`:

```ts
/**
 * LRU Cache Implementation
 *
 * A generic Least Recently Used cache with a fixed size limit.
 * Used to managed memory usage for conversation caches in long-running sessions.
 */
export class LRUCache<K, V> {
    private cache = new Map<K, V>();
    private readonly maxSize: number;

    constructor(maxSize: number) {
        if (maxSize <= 0) {
            throw new Error('LRUCache max size must be greater than 0');
        }
        this.maxSize = maxSize;
    }

    get(key: K): V | undefined {
        if (!this.cache.has(key)) {
            return undefined;
        }

        // Refresh item position (delete and re-add)
        const value = this.cache.get(key) as V;
        this.cache.delete(key);
        this.cache.set(key, value);

        return value;
    }

    set(key: K, value: V): void {
        if (this.cache.has(key)) {
            // If exists, refresh position
            this.cache.delete(key);
        } else if (this.cache.size >= this.maxSize) {
            // Evict oldest (first item in Map)
            const oldestKey = this.cache.keys().next().value;
            if (oldestKey !== undefined) {
                this.cache.delete(oldestKey);
            }
        }

        this.cache.set(key, value);
    }

    has(key: K): boolean {
        return this.cache.has(key);
    }

    delete(key: K): boolean {
        return this.cache.delete(key);
    }

    clear(): void {
        this.cache.clear();
    }

    get size(): number {
        return this.cache.size;
    }

    keys(): IterableIterator<K> {
        return this.cache.keys();
    }

    values(): IterableIterator<V> {
        return this.cache.values();
    }
}

```

`utils/managers/interception-manager.ts`:

```ts
/**
 * Interception Manager
 *
 * Handles listening for intercepted data messages from the content script interceptor.
 * Parses raw data using the appropriate platform adapter.
 * Manages the LRU cache of validation conversation data.
 */

import type { LLMPlatform } from '@/platforms/types';
import { logger } from '@/utils/logger';
import { LRUCache } from '@/utils/lru-cache';
import type { ConversationData } from '@/utils/types';

export class InterceptionManager {
    private readonly conversationCache: LRUCache<string, ConversationData>;
    private currentAdapter: LLMPlatform | null = null;

    // Callback to notify the runner (and UI) that new valid data has been intercepted/cached
    private onDataCaptured: (conversationId: string) => void;

    constructor(onDataCaptured: (conversationId: string) => void) {
        this.conversationCache = new LRUCache<string, ConversationData>(10);
        this.onDataCaptured = onDataCaptured;
    }

    public updateAdapter(adapter: LLMPlatform | null) {
        this.currentAdapter = adapter;
    }

    public start(): void {
        window.addEventListener('message', this.handleMessage);
    }

    public stop(): void {
        window.removeEventListener('message', this.handleMessage);
    }

    public getConversation(id: string): ConversationData | undefined {
        return this.conversationCache.get(id);
    }

    private handleMessage = (event: MessageEvent): void => {
        if (event.source !== window) {
            return;
        }

        const message = event.data;

        // Handle logs
        if (message?.type === 'LLM_LOG_ENTRY') {
            this.handleLogEntry(message.payload);
            return;
        }

        // Handle intercepted data
        if (message?.type === 'LLM_CAPTURE_DATA_INTERCEPTED' && message.data) {
            this.handleInterceptedData(message);
        }
    };

    private handleLogEntry(payload: any): void {
        const { level, message: logMessage, data, context } = payload;
        const prefixedMsg = `[${context}] ${logMessage}`;

        if (level === 'error') {
            logger.error(prefixedMsg, ...(data || []));
        } else if (level === 'warn') {
            logger.warn(prefixedMsg, ...(data || []));
        } else {
            logger.info(prefixedMsg, ...(data || []));
        }
    }

    private handleInterceptedData(message: any): void {
        logger.info('Received intercepted data message');

        if (!this.currentAdapter) {
            logger.warn('No currentAdapter in manager, ignoring message');
            return;
        }

        try {
            const data = this.currentAdapter.parseInterceptedData(message.data, message.url);

            if (data?.conversation_id) {
                const conversationId = data.conversation_id;
                this.conversationCache.set(conversationId, data);

                logger.info(`Successfully captured/cached data for conversation: ${conversationId}`);

                // Notify runner to update UI if this matches current view
                this.onDataCaptured(conversationId);
            } else {
                logger.warn('Failed to parse conversation ID from intercepted data');
            }
        } catch (error) {
            logger.error('Error parsing intercepted data:', error);
        }
    }
}

```

`utils/managers/navigation-manager.ts`:

```ts
/**
 * Navigation Manager
 *
 * Handles monitoring for page navigation and DOM changes.
 * Uses MutationObserver and History API hooks to detect when the user moves
 * between conversations or when the page structure updates (SPA navigation).
 */
import { logger } from '@/utils/logger';

export class NavigationManager {
    private observer: MutationObserver | null = null;
    private navigationTimeout: number | undefined;
    private onNavigationChange: () => void;

    constructor(onNavigationChange: () => void) {
        this.onNavigationChange = onNavigationChange;
    }

    public start(): void {
        this.setupMutationObserver();
        this.setupHistoryListeners();
        logger.info('NavigationManager started');
    }

    public stop(): void {
        if (this.observer) {
            this.observer.disconnect();
            this.observer = null;
        }
        window.removeEventListener('popstate', this.onNavigationChange);

        // Note: we can't easily remove the patched pushState/replaceState hooks
        // safely without potentially breaking other scripts, so we leave them be.
        // This is a trade-off for SPA monitoring.
    }

    private setupMutationObserver(): void {
        this.observer = new MutationObserver(() => {
            if (this.navigationTimeout) {
                clearTimeout(this.navigationTimeout);
            }

            // Debounce navigation checks
            this.navigationTimeout = window.setTimeout(() => {
                this.onNavigationChange();
            }, 300); // 300ms debounce
        });

        // Optimization: In the future, we can target specific containers per platform.
        // For now, observing body is necessary for generic SPA support but verified
        // Performance impact is acceptable with debounce.
        this.observer.observe(document.body, {
            childList: true,
            subtree: true,
        });
    }

    private setupHistoryListeners(): void {
        window.addEventListener('popstate', this.onNavigationChange);

        // Monkey-patch history to detect pushState/replaceState
        // This is standard for SPA extensions to catch soft navigations
        const originalPushState = history.pushState;
        history.pushState = (...args) => {
            originalPushState.apply(history, args);
            this.onNavigationChange();
        };

        const originalReplaceState = history.replaceState;
        history.replaceState = (...args) => {
            originalReplaceState.apply(history, args);
            this.onNavigationChange();
        };
    }
}

```

`utils/platform-runner.test.ts`:

```ts
import { beforeEach, describe, expect, it, mock } from 'bun:test';
import { Window } from 'happy-dom';

// Configure Happy DOM
const window = new Window();
const document = window.document;
(global as any).window = window;
(global as any).document = document;
(global as any).history = window.history;
(global as any).HTMLElement = window.HTMLElement;
(global as any).HTMLButtonElement = window.HTMLButtonElement;
(global as any).MutationObserver = window.MutationObserver;

// Mock dependencies
const mockAdapter = {
    name: 'TestPlatform',
    extractConversationId: () => '123',
    getButtonInjectionTarget: () => document.body,
    formatFilename: () => 'test.json',
    parseInterceptedData: () => ({ conversation_id: '123' }),
};

// We need a mutable reference to control the mock return value
let currentAdapterMock: any = mockAdapter;

// Mock the factory module
mock.module('@/platforms/factory', () => ({
    getPlatformAdapter: () => currentAdapterMock,
    getPlatformAdapterByApiUrl: () => currentAdapterMock,
}));

// Mock wxt/browser explicitly for this test file to prevent logger errors
const browserMock = {
    storage: {
        local: {
            get: async () => ({}),
            set: async () => {},
        },
    },
    runtime: {
        getURL: () => 'chrome-extension://mock/',
    },
};
mock.module('wxt/browser', () => ({
    browser: browserMock,
}));

// Import subject under test AFTER mocking
import { runPlatform } from './platform-runner';

describe('Platform Runner', () => {
    beforeEach(() => {
        // Reset DOM
        document.body.innerHTML = '';
        currentAdapterMock = mockAdapter;

        // Mock window.location properties
        const locationMock = {
            href: 'https://test.com/c/123',
            origin: 'https://test.com',
        };

        delete (window as any).location;
        (window as any).location = locationMock;
    });

    it('should inject button when valid adapter and ID found', async () => {
        runPlatform();

        // Wait for async injection logic
        await new Promise((resolve) => setTimeout(resolve, 100));

        const btn = document.getElementById('llm-capture-save-btn');
        expect(btn).not.toBeNull();
        expect(btn?.textContent).toContain('Save JSON');
    });

    it('should NOT inject button if no adapter matches', async () => {
        currentAdapterMock = null;
        runPlatform();

        await new Promise((resolve) => setTimeout(resolve, 100));

        const btn = document.getElementById('llm-capture-save-btn');
        expect(btn).toBeNull();
    });
});

```

`utils/platform-runner.ts`:

```ts
/**
 * Platform Runner Utility
 *
 * Orchestrator that ties together the specialized managers for:
 * - UI (ButtonManager)
 * - Data (InterceptionManager)
 * - Navigation (NavigationManager)
 *
 * @module utils/platform-runner
 */

import { getPlatformAdapter } from '@/platforms/factory';
import type { LLMPlatform } from '@/platforms/types';
import { downloadAsJSON } from '@/utils/download';
import { logger } from '@/utils/logger';
import { InterceptionManager } from '@/utils/managers/interception-manager';
import { NavigationManager } from '@/utils/managers/navigation-manager';
import { ButtonManager } from '@/utils/ui/button-manager';

export function runPlatform(): void {
    let currentAdapter: LLMPlatform | null = null;
    let currentConversationId: string | null = null;

    // -- Manager Initialization --

    // 1. UI Manager
    const buttonManager = new ButtonManager(handleSaveClick);

    // 2. Data Manager
    const interceptionManager = new InterceptionManager((capturedId) => {
        // Callback when data is captured
        const currentId = currentAdapter?.extractConversationId(window.location.href);
        if (currentId && currentId === capturedId && buttonManager.exists()) {
            buttonManager.setOpacity('1');
        }
    });

    // 3. Navigation Manager
    const navigationManager = new NavigationManager(() => {
        handleNavigationChange();
    });

    /**
     * Core orchestrator logic functions
     */

    async function handleSaveClick(): Promise<void> {
        if (!currentAdapter) {
            return;
        }

        const conversationId = currentAdapter.extractConversationId(window.location.href);
        if (!conversationId) {
            logger.error('No conversation ID found in URL');
            alert('Please select a conversation first.');
            return;
        }

        const data = interceptionManager.getConversation(conversationId);
        if (!data) {
            logger.warn('No data captured for this conversation yet.');
            alert('Conversation data not yet captured. Please refresh the page or wait for the conversation to load.');
            return;
        }

        buttonManager.setLoading(true);
        try {
            const filename = currentAdapter.formatFilename(data);
            downloadAsJSON(data, filename);
            logger.info(`Saved conversation: ${filename}.json`);
        } catch (error) {
            logger.error('Failed to save conversation:', error);
            alert('Failed to save conversation. Check console for details.');
        } finally {
            buttonManager.setLoading(false);
        }
    }

    function injectSaveButton(): void {
        const conversationId = currentAdapter?.extractConversationId(window.location.href) || null;
        if (!conversationId) {
            logger.debug('No conversation ID found. Button will not be injected.');
            buttonManager.remove();
            return;
        }

        const target = currentAdapter?.getButtonInjectionTarget();
        if (!target) {
            logger.debug('Injection target not found, will retry...');
            return;
        }

        buttonManager.inject(target, conversationId);
        currentConversationId = conversationId;

        // Check if we already have data
        const hasData = interceptionManager.getConversation(conversationId);
        if (hasData) {
            buttonManager.setOpacity('1');
        } else {
            buttonManager.setOpacity('0.6');
        }
    }

    function handleNavigationChange(): void {
        if (!currentAdapter) {
            return;
        }

        const newConversationId = currentAdapter.extractConversationId(window.location.href);
        if (newConversationId !== currentConversationId) {
            buttonManager.remove();
            if (newConversationId) {
                // Determine if we need to update adapter (e.g. cross-platform nav? likely not in same tab but good practice)
                const newAdapter = getPlatformAdapter(window.location.href);
                if (newAdapter && newAdapter.name !== currentAdapter.name) {
                    currentAdapter = newAdapter;
                    updateManagers();
                }

                setTimeout(injectSaveButton, 500);
            }
        } else {
            // ID hasn't changed, but maybe DOM has (re-render), ensure button exists
            if (newConversationId && !buttonManager.exists()) {
                setTimeout(injectSaveButton, 500);
            }
        }
    }

    function updateManagers(): void {
        interceptionManager.updateAdapter(currentAdapter);
    }

    // -- Boot Sequence --

    const url = window.location.href;
    currentAdapter = getPlatformAdapter(url);

    if (!currentAdapter) {
        logger.warn('No matching platform adapter for this URL');
        return;
    }

    logger.info(`Content script running for ${currentAdapter.name}`);

    // Update managers with initial adapter
    updateManagers();

    // Start listening
    interceptionManager.start();
    navigationManager.start();

    // Initial injection
    currentConversationId = currentAdapter.extractConversationId(url);
    injectSaveButton();

    // Retry logic for initial load (sometimes SPA takes time to render header)
    const retryIntervals = [1000, 2000, 5000];
    for (const delay of retryIntervals) {
        setTimeout(() => {
            if (!buttonManager.exists()) {
                injectSaveButton();
            }
        }, delay);
    }
}

```

`utils/types.test.ts`:

```ts
/**
 * Tests for ChatGPT Conversation Data Parsing
 *
 * TDD tests for parsing real ChatGPT API response data
 */

import { describe, expect, it } from 'bun:test';
import sampleConversation from '@/data/chatgpt/sample_chatgpt_conversation.json';
import type { ConversationData, MessageNode } from '@/utils/types';

describe('ChatGPT Conversation Data Parsing', () => {
    // Type assertion to verify the sample data matches our types
    const conversation = sampleConversation as ConversationData;

    describe('top-level fields', () => {
        it('should have a title string', () => {
            expect(typeof conversation.title).toBe('string');
            expect(conversation.title).toBe('Sample Conversation');
        });

        it('should have create_time and update_time as numbers', () => {
            expect(typeof conversation.create_time).toBe('number');
            expect(typeof conversation.update_time).toBe('number');
            expect(conversation.create_time).toBeGreaterThan(0);
            expect(conversation.update_time).toBeGreaterThanOrEqual(conversation.create_time);
        });

        it('should have a valid conversation_id', () => {
            expect(typeof conversation.conversation_id).toBe('string');
            expect(conversation.conversation_id).toMatch(
                /^[a-f0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$/,
            );
        });

        it('should have a current_node pointing to a valid node', () => {
            expect(typeof conversation.current_node).toBe('string');
            expect(conversation.mapping[conversation.current_node]).toBeDefined();
        });

        it('should have a mapping object with message nodes', () => {
            expect(typeof conversation.mapping).toBe('object');
            expect(Object.keys(conversation.mapping).length).toBeGreaterThan(0);
        });
    });

    describe('message node structure', () => {
        it('should have valid message nodes with required fields', () => {
            for (const [nodeId, node] of Object.entries(conversation.mapping)) {
                const messageNode = node as MessageNode;

                expect(messageNode.id).toBe(nodeId);
                expect(Array.isArray(messageNode.children)).toBe(true);

                // parent can be null for root node
                if (messageNode.parent !== null) {
                    expect(typeof messageNode.parent).toBe('string');
                    // Parent should exist in mapping
                    expect(conversation.mapping[messageNode.parent]).toBeDefined();
                }
            }
        });

        it('should have messages with author roles', () => {
            const nodesWithMessages = Object.values(conversation.mapping).filter(
                (node) => (node as MessageNode).message !== null,
            );

            expect(nodesWithMessages.length).toBeGreaterThan(0);

            for (const node of nodesWithMessages) {
                const messageNode = node as MessageNode;
                const message = messageNode.message!;

                expect(['system', 'user', 'assistant', 'tool']).toContain(message.author.role);
            }
        });

        it('should have user and assistant messages', () => {
            const roles = new Set<string>();

            for (const node of Object.values(conversation.mapping)) {
                const messageNode = node as MessageNode;
                if (messageNode.message?.author?.role) {
                    roles.add(messageNode.message.author.role);
                }
            }

            expect(roles.has('user')).toBe(true);
            expect(roles.has('assistant')).toBe(true);
        });

        it('should have message content with content_type', () => {
            const nodesWithMessages = Object.values(conversation.mapping).filter(
                (node) => (node as MessageNode).message !== null,
            );

            for (const node of nodesWithMessages) {
                const messageNode = node as MessageNode;
                const message = messageNode.message!;

                expect(typeof message.content.content_type).toBe('string');
                expect(['text', 'thoughts', 'reasoning_recap', 'code', 'execution_output']).toContain(
                    message.content.content_type,
                );
            }
        });
    });

    describe('message tree structure', () => {
        it('should have a root node with no parent', () => {
            const rootNodes = Object.values(conversation.mapping).filter(
                (node) => (node as MessageNode).parent === null,
            );

            expect(rootNodes.length).toBe(1);
        });

        it('should form a valid tree structure (children reference valid nodes)', () => {
            for (const node of Object.values(conversation.mapping)) {
                const messageNode = node as MessageNode;

                for (const childId of messageNode.children) {
                    expect(conversation.mapping[childId]).toBeDefined();
                    expect((conversation.mapping[childId] as MessageNode).parent).toBe(messageNode.id);
                }
            }
        });

        it('should have current_node as a leaf or valid node in the tree', () => {
            const currentNode = conversation.mapping[conversation.current_node] as MessageNode;
            expect(currentNode).toBeDefined();
            // Current node should be reachable from root
        });
    });

    describe('optional fields', () => {
        it('should handle optional fields correctly', () => {
            // These fields can be null or have values
            expect(conversation.plugin_ids === null || Array.isArray(conversation.plugin_ids)).toBe(true);
            expect(conversation.gizmo_id === null || typeof conversation.gizmo_id === 'string').toBe(true);
            expect(typeof conversation.is_archived).toBe('boolean');
            expect(Array.isArray(conversation.safe_urls)).toBe(true);
            expect(Array.isArray(conversation.blocked_urls)).toBe(true);
        });
    });

    describe('content types', () => {
        it('should have text content with parts array', () => {
            const textNodes = Object.values(conversation.mapping).filter((node) => {
                const messageNode = node as MessageNode;
                return messageNode.message?.content?.content_type === 'text';
            });

            expect(textNodes.length).toBeGreaterThan(0);

            for (const node of textNodes) {
                const messageNode = node as MessageNode;
                expect(Array.isArray(messageNode.message!.content.parts)).toBe(true);
            }
        });

        it('should have thoughts content with thoughts array', () => {
            const thoughtNodes = Object.values(conversation.mapping).filter((node) => {
                const messageNode = node as MessageNode;
                return messageNode.message?.content?.content_type === 'thoughts';
            });

            expect(thoughtNodes.length).toBeGreaterThan(0);

            for (const node of thoughtNodes) {
                const messageNode = node as MessageNode;
                expect(Array.isArray(messageNode.message!.content.thoughts)).toBe(true);

                for (const thought of messageNode.message!.content.thoughts!) {
                    expect(typeof thought.summary).toBe('string');
                    expect(typeof thought.content).toBe('string');
                    expect(Array.isArray(thought.chunks)).toBe(true);
                    expect(typeof thought.finished).toBe('boolean');
                }
            }
        });

        it('should have reasoning_recap content', () => {
            const recapNodes = Object.values(conversation.mapping).filter((node) => {
                const messageNode = node as MessageNode;
                return messageNode.message?.content?.content_type === 'reasoning_recap';
            });

            expect(recapNodes.length).toBeGreaterThan(0);

            for (const node of recapNodes) {
                const messageNode = node as MessageNode;
                expect(typeof messageNode.message!.content.content).toBe('string');
            }
        });
    });
});

```

`utils/types.ts`:

```ts
/**
 * Type definitions for Blackiya extension
 *
 * @module utils/types
 */

/**
 * Author information for a message in a ChatGPT conversation
 */
export interface Author {
    role: 'system' | 'user' | 'assistant' | 'tool';
    name: string | null;
    metadata: Record<string, unknown>;
}

/**
 * Content of a message - can be text, thoughts, or other content types
 */
export interface MessageContent {
    content_type: 'text' | 'thoughts' | 'reasoning_recap' | 'code' | 'execution_output';
    parts?: string[];
    thoughts?: Array<{
        summary: string;
        content: string;
        chunks: string[];
        finished: boolean;
    }>;
    content?: string;
}

/**
 * A single message in a conversation
 */
export interface Message {
    id: string;
    author: Author;
    create_time: number | null;
    update_time: number | null;
    content: MessageContent;
    status: 'finished_successfully' | 'in_progress' | 'error';
    end_turn: boolean | null;
    weight: number;
    metadata: Record<string, unknown>;
    recipient: string;
    channel: string | null;
}

/**
 * A node in the conversation message tree
 */
export interface MessageNode {
    id: string;
    message: Message | null;
    parent: string | null;
    children: string[];
}

/**
 * Full conversation data structure from ChatGPT API
 */
export interface ConversationData {
    title: string;
    create_time: number;
    update_time: number;
    mapping: Record<string, MessageNode>;
    conversation_id: string;
    current_node: string;
    moderation_results: unknown[];
    plugin_ids: string[] | null;
    gizmo_id: string | null;
    gizmo_type: string | null;
    is_archived: boolean;
    default_model_slug: string;
    safe_urls: string[];
    blocked_urls: string[];
}

```

`utils/ui/button-manager.ts`:

```ts
/**
 * Button Manager Utility
 *
 * Handles the creation, styling, injecting, and state management of the "Save JSON" button.
 * Decoupled from data processing logic.
 */
import { logger } from '@/utils/logger';

export class ButtonManager {
    private button: HTMLButtonElement | null = null;
    private isFixedPosition = false;
    private onSaveClick: () => Promise<void>;

    constructor(onSaveClick: () => Promise<void>) {
        this.onSaveClick = onSaveClick;
        this.injectStyles();
    }

    public inject(target: HTMLElement, conversationId: string | null): void {
        if (this.button && document.contains(this.button)) {
            return;
        }

        this.button = this.createButton();

        // Fixed position fallback logic
        if (target === document.body || target === document.documentElement) {
            this.isFixedPosition = true;
            this.updateStyles('default');
        } else {
            this.isFixedPosition = false;
            // Reset to default inline styles if previously fixed
            this.button.style.cssText = this.getStyles('default');
        }

        target.appendChild(this.button);
        logger.info(`Save button injected for conversation: ${conversationId}`);
    }

    public remove(): void {
        if (this.button?.parentElement) {
            this.button.parentElement.removeChild(this.button);
        }
        this.button = null;
    }

    public exists(): boolean {
        return !!this.button && document.contains(this.button);
    }

    public setLoading(loading: boolean): void {
        if (!this.button) {
            return;
        }

        this.button.disabled = loading;
        this.button.innerHTML = ''; // Clear safely

        if (loading) {
            const icon = this.createIconSVG('loading');
            const textSpan = document.createElement('span');
            textSpan.textContent = 'Saving...';
            this.button.appendChild(icon);
            this.button.appendChild(textSpan);
            this.updateStyles('loading');
        } else {
            const icon = this.createIconSVG('save');
            const textSpan = document.createElement('span');
            textSpan.textContent = 'Save JSON';
            this.button.appendChild(icon);
            this.button.appendChild(textSpan);
            this.updateStyles('default');
        }
    }

    public setOpacity(opacity: string): void {
        if (this.button) {
            this.button.style.opacity = opacity;
        }
    }

    private createButton(): HTMLButtonElement {
        const button = document.createElement('button');
        button.id = 'llm-capture-save-btn';

        const icon = this.createIconSVG('save');
        const textSpan = document.createElement('span');
        textSpan.textContent = 'Save JSON';

        button.appendChild(icon);
        button.appendChild(textSpan);

        button.style.cssText = this.getStyles('default');

        button.addEventListener('mouseenter', () => {
            if (!button.disabled) {
                this.updateStyles('hover');
            }
        });

        button.addEventListener('mouseleave', () => {
            if (!button.disabled) {
                this.updateStyles('default');
            }
        });

        button.addEventListener('click', this.onSaveClick);

        // If we have an ID but no data yet (handled by caller logic typically,
        // but here we just set initial opacity if passed)
        // logic moved to orchestration, but keeping opacity control public

        return button;
    }

    private updateStyles(state: 'default' | 'hover' | 'loading'): void {
        if (!this.button) {
            return;
        }
        this.button.style.cssText = this.getStyles(state);
    }

    private getStyles(state: 'default' | 'hover' | 'loading'): string {
        let css = `
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            margin-left: 8px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #10a37f 0%, #0d8a6a 100%);
            color: white;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(16, 163, 127, 0.2);
            z-index: 9999;
        `;

        if (state === 'hover') {
            css += `
                background: linear-gradient(135deg, #0d8a6a 0%, #0a7359 100%);
                box-shadow: 0 4px 8px rgba(16, 163, 127, 0.3);
                transform: translateY(-1px);
            `;
        } else if (state === 'loading') {
            css += `
                opacity: 0.7;
                cursor: wait;
            `;
        }

        if (this.isFixedPosition) {
            css += `
                position: fixed;
                bottom: 20px;
                right: 20px;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            `;
        }

        return css;
    }

    private createIconSVG(iconType: 'save' | 'loading'): SVGSVGElement {
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', '16');
        svg.setAttribute('height', '16');
        svg.setAttribute('viewBox', '0 0 24 24');
        svg.setAttribute('fill', 'none');
        svg.setAttribute('stroke', 'currentColor');
        svg.setAttribute('stroke-width', '2');

        if (iconType === 'loading') {
            svg.style.animation = 'spin 1s linear infinite';
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', '12');
            circle.setAttribute('cy', '12');
            circle.setAttribute('r', '10');
            circle.setAttribute('stroke-dasharray', '32');
            circle.setAttribute('stroke-dashoffset', '8');
            svg.appendChild(circle);
        } else {
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', 'M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4');
            const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
            polyline.setAttribute('points', '7 10 12 15 17 10');
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', '12');
            line.setAttribute('y1', '15');
            line.setAttribute('x2', '12');
            line.setAttribute('y2', '3');
            svg.appendChild(path);
            svg.appendChild(polyline);
            svg.appendChild(line);
        }
        return svg;
    }

    private injectStyles(): void {
        const styleId = 'blackiya-button-styles';
        if (document.getElementById(styleId)) {
            return;
        }

        const style = document.createElement('style');
        style.id = styleId;
        style.textContent = `
            @keyframes spin {
                from { transform: rotate(0deg); }
                to { transform: rotate(360deg); }
            }
        `;
        document.head.appendChild(style);
    }
}

```

`wxt.config.ts`:

```ts
import { defineConfig } from 'wxt';
import { SUPPORTED_PLATFORM_URLS } from './platforms/constants';

// See https://wxt.dev/api/config.html
export default defineConfig({
    modules: ['@wxt-dev/module-react'],
    manifest: {
        name: 'Blackiya',
        description: 'Capture and save conversation JSON from ChatGPT, Gemini, and other LLMs',
        permissions: ['storage', 'activeTab', 'downloads'],
        host_permissions: [...SUPPORTED_PLATFORM_URLS],
        action: {
            default_icon: 'icon.png',
        },
        icons: {
            '16': 'icon/16.png',
            '32': 'icon/32.png',
            '48': 'icon/48.png',
            '128': 'icon/128.png',
        },
    },
});

```